{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QuatIca Documentation","text":"<p>Welcome to QuatIca - a comprehensive quaternion linear algebra library for Python. This documentation provides everything you need to get started with quaternion matrix operations, decompositions, and real-world applications.</p>"},{"location":"#quick-navigation","title":"\ud83d\ude80 Quick Navigation","text":""},{"location":"#new-to-quatica","title":"New to QuatIca?","text":"<ul> <li>Getting Started - Complete setup guide from installation to first run</li> <li>Examples - Copy-paste commands and code snippets</li> <li>Tutorial - Interactive learning with <code>python run_analysis.py tutorial</code></li> </ul>"},{"location":"#applications","title":"Applications","text":"<ul> <li>Image Deblurring - QSLST vs Newton-Schulz methods</li> <li>Image Completion - Advanced restoration using quaternion matrices</li> <li>Lorenz Attractor Filtering - Quaternion signal processing with chaotic systems</li> <li>Matrix Analysis - Pseudoinverse and decomposition benchmarks</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>API Documentation - Complete function reference</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"#what-is-quatica","title":"\u26a1 What is QuatIca?","text":"<p>QuatIca brings modern numerical linear algebra to quaternion matrices and tensors:</p> <ul> <li>Matrix Operations: Multiplication, norms, Hermitian conjugate, sparse support</li> <li>Decompositions: QR, SVD, LU, eigendecomposition, Schur, Hessenberg</li> <li>Solvers: Newton-Schulz pseudoinverse, Q-GMRES with LU preconditioning</li> <li>Applications: Image deblurring, image completion, quaternion signal processing</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u26a1 Fast: numpy\u22652.3.2 provides 10-15x speedup for quaternion operations</li> <li>\ud83e\uddea Tested: 194 passing tests with comprehensive validation</li> <li>\ud83c\udfaf Practical: Real-world applications with saved outputs</li> <li>\ud83d\udcca Visual: Rich plotting and analysis tools</li> </ul>"},{"location":"#quick-examples","title":"\ud83c\udfaf Quick Examples","text":""},{"location":"#2-minute-setup","title":"2-Minute Setup","text":"<pre><code># Create environment and install\npython3 -m venv quatica &amp;&amp; source quatica/bin/activate\npip install -r requirements.txt\n\n# Run interactive tutorial\npython run_analysis.py tutorial\n</code></pre>"},{"location":"#common-tasks","title":"Common Tasks","text":"<pre><code># Image processing\npython run_analysis.py image_deblurring\n\n# Signal processing\npython run_analysis.py lorenz_signal\n\n# Linear system solving\npython run_analysis.py qgmres\n\n# Performance benchmarking\npython run_analysis.py lorenz_benchmark\n</code></pre>"},{"location":"#basic-code","title":"Basic Code","text":"<pre><code>import numpy as np\nimport quaternion\nfrom quatica.utils import quat_matmat, quat_frobenius_norm\nfrom quatica.solver import NewtonSchulzPseudoinverse\n\n# Create quaternion matrices\nA = quaternion.as_quat_array(np.random.randn(4, 4, 4))\nB = quaternion.as_quat_array(np.random.randn(4, 4, 4))\n\n# Matrix operations\nC = quat_matmat(A, B)\nnorm_A = quat_frobenius_norm(A)\n\n# Pseudoinverse computation\nsolver = NewtonSchulzPseudoinverse()\nA_pinv, residuals, _ = solver.compute(A)\n</code></pre>"},{"location":"#research-applications","title":"\ud83d\udd2c Research Applications","text":"<p>QuatIca supports cutting-edge research in:</p> <ul> <li>Quaternion Signal Processing: 3D/4D signal analysis</li> <li>Image Restoration: Deblurring, completion, inpainting</li> <li>Matrix Theory: Quaternion decompositions and eigenanalysis</li> <li>Numerical Methods: Iterative solvers and preconditioning</li> </ul>"},{"location":"#recent-algorithms","title":"Recent Algorithms","text":"<ul> <li>QSLST: Quaternion Special Least Squares with Tikhonov regularization</li> <li>Q-GMRES: Generalized Minimal Residual method for quaternion systems</li> <li>Randomized Q-SVD: Fast approximation for large quaternion matrices</li> <li>Higher-Order Newton-Schulz: Cubic convergence for pseudoinverse computation</li> </ul>"},{"location":"#performance-highlights","title":"\ud83d\udcca Performance Highlights","text":"Operation Matrix Size Time Accuracy Q-SVD 100\u00d7100 ~0.5s Machine precision Pseudoinverse 200\u00d7200 ~0.4s Residual &lt; 10\u207b\u00b9\u2075 Q-GMRES 500\u00d7500 ~2.0s Converges in &lt;50 iterations Image Deblurring 64\u00d764 ~0.1s &gt;35 dB PSNR"},{"location":"#learning-path","title":"\ud83c\udf93 Learning Path","text":""},{"location":"#beginners","title":"Beginners","text":"<ol> <li>Getting Started - Setup and verification</li> <li>Tutorial: <code>python run_analysis.py tutorial</code> - Interactive learning</li> <li>Examples - Copy-paste code snippets</li> </ol>"},{"location":"#intermediate-users","title":"Intermediate Users","text":"<ol> <li>API Reference - Function documentation</li> <li>Applications: Try image deblurring, completion, and Lorenz attractor filtering</li> <li>Custom matrices: Learn quaternion matrix creation patterns</li> </ol>"},{"location":"#advanced-users","title":"Advanced Users","text":"<ol> <li>Algorithm comparison: Benchmark different methods</li> <li>Performance optimization: Large-scale problems</li> <li>Research applications: Extend with new algorithms</li> </ol>"},{"location":"#external-resources","title":"\ud83d\udd17 External Resources","text":"<ul> <li>GitHub Repository: https://github.com/vleplat/QuatIca</li> <li>Issue Tracker: https://github.com/vleplat/QuatIca/issues</li> <li>QTFM (MATLAB): Original inspiration for quaternion linear algebra</li> <li>Research Papers: References included in function documentation</li> </ul>"},{"location":"#support","title":"\ud83d\udce7 Support","text":"<ul> <li>Documentation: Complete guides and API reference on this site</li> <li>Community: GitHub Issues for questions and bug reports</li> <li>Contact: v dot leplat [at] innopolis dot ru</li> <li>License: CC0 1.0 Universal (public domain)</li> </ul> <p>Ready to start? Head to Getting Started for installation, or dive into Examples for immediate copy-paste commands!</p>"},{"location":"examples/","title":"Examples","text":"<p>Quick copy-paste examples to get you started with QuatIca.</p>"},{"location":"examples/#quick-start-commands","title":"\ud83d\ude80 Quick Start Commands","text":""},{"location":"examples/#learn-the-framework","title":"Learn the Framework","text":"<pre><code># Start here - interactive tutorial with visualizations\npython run_analysis.py tutorial\n\n# Core functionality demo (comprehensive overview)\npython run_analysis.py demo\n</code></pre>"},{"location":"examples/#linear-system-solving","title":"Linear System Solving","text":"<pre><code># Basic Q-GMRES solver test\npython run_analysis.py qgmres\n\n# Q-GMRES with LU preconditioning benchmark\npython run_analysis.py qgmres_bench\n</code></pre>"},{"location":"examples/#signal-processing","title":"Signal Processing","text":"<pre><code># Lorenz attractor processing (default quality)\npython run_analysis.py lorenz_signal\n\n# Fast testing (100 points, ~30s)\npython run_analysis.py lorenz_signal --num_points 100\n\n# High quality (500 points, ~5-10min)\npython run_analysis.py lorenz_signal --num_points 500\n\n# Method comparison benchmark\npython run_analysis.py lorenz_benchmark\n</code></pre>"},{"location":"examples/#image-processing","title":"Image Processing","text":"<pre><code># Real image completion\npython run_analysis.py image_completion\n\n# Quaternion image deblurring (recommended)\npython run_analysis.py image_deblurring --size 64 --lam 1e-3 --snr 40 --ns_mode fftT --fftT_order 3 --ns_iters 12\n\n# Synthetic image completion\npython run_analysis.py synthetic\n\n# Test pseudoinverse on synthetic matrices\npython run_analysis.py synthetic_matrices\n</code></pre>"},{"location":"examples/#matrix-decompositions","title":"Matrix Decompositions","text":"<pre><code># Eigenvalue decomposition test\npython run_analysis.py eigenvalue_test\n\n# Quaternion Schur decomposition demo\npython run_analysis.py schur_demo\n\n# Schur with custom matrix size\npython run_analysis.py schur_demo 25\n\n# Compare Newton-Schulz variants\npython run_analysis.py ns_compare\n</code></pre>"},{"location":"examples/#code-examples","title":"\ud83d\udcdd Code Examples","text":""},{"location":"examples/#basic-quaternion-matrix-operations","title":"Basic Quaternion Matrix Operations","text":"<pre><code>import numpy as np\nimport quaternion\nfrom quatica.utils import quat_matmat, quat_frobenius_norm, quat_eye\n\n# Create quaternion matrices\nA = quaternion.as_quat_array(np.random.randn(4, 4, 4))\nB = quaternion.as_quat_array(np.random.randn(4, 4, 4))\n\n# Matrix multiplication\nC = quat_matmat(A, B)\n\n# Compute Frobenius norm\nnorm_A = quat_frobenius_norm(A)\nprint(f\"Frobenius norm: {norm_A:.6f}\")\n\n# Identity matrix\nI = quat_eye(4)\n</code></pre>"},{"location":"examples/#pseudoinverse-computation","title":"Pseudoinverse Computation","text":"<pre><code>from quatica.solver import NewtonSchulzPseudoinverse, HigherOrderNewtonSchulzPseudoinverse\n\n# Standard Newton-Schulz pseudoinverse\nns_solver = NewtonSchulzPseudoinverse(gamma=0.5, max_iter=100, tol=1e-6)\nA_pinv, residuals, covariances = ns_solver.compute(A)\n\n# Higher-order Newton-Schulz (cubic convergence)\nhon_solver = HigherOrderNewtonSchulzPseudoinverse(max_iter=50, tol=1e-8)\nA_pinv_hon, residuals_hon, covariances_hon = hon_solver.compute(A)\n</code></pre>"},{"location":"examples/#q-gmres-linear-system-solving","title":"Q-GMRES Linear System Solving","text":"<pre><code>from quatica.solver import QGMRESSolver\n\n# Create Q-GMRES solver\nqgmres_solver = QGMRESSolver(tol=1e-6, max_iter=100, verbose=True)\n\n# Solve linear system A*x = b\nb = quaternion.as_quat_array(np.random.randn(4, 1, 4))\nx, info = qgmres_solver.solve(A, b)\n\nprint(f\"Converged in {info['iterations']} iterations\")\nprint(f\"Final residual: {info['residual']:.2e}\")\n\n# With LU preconditioning for better convergence\nqgmres_lu = QGMRESSolver(tol=1e-6, max_iter=100, preconditioner='left_lu')\nx_prec, info_prec = qgmres_lu.solve(A, b)\n</code></pre>"},{"location":"examples/#matrix-decompositions_1","title":"Matrix Decompositions","text":"<pre><code>from quatica.decomp.qsvd import qr_qua, classical_qsvd, classical_qsvd_full\nfrom quatica.decomp.eigen import quaternion_eigendecomposition\nfrom quatica.decomp.LU import quaternion_lu\n\n# QR decomposition\nQ, R = qr_qua(A)\n\n# Quaternion SVD (truncated)\nU, s, V = classical_qsvd(A, rank=2)\n\n# Full SVD\nU_full, s_full, V_full = classical_qsvd_full(A)\n\n# Eigendecomposition (Hermitian matrices only)\nA_hermitian = A + quat_hermitian(A)  # Make it Hermitian\neigenvals, eigenvecs = quaternion_eigendecomposition(A_hermitian)\n\n# LU decomposition\nL, U, P = quaternion_lu(A, return_p=True)\n</code></pre>"},{"location":"examples/#custom-matrix-creation","title":"Custom Matrix Creation","text":"<pre><code># Create Pauli matrices in quaternion format\ndef create_pauli_matrices():\n    # \u03c3\u2080 (identity)\n    sigma_0_array = np.zeros((2, 2, 4))\n    sigma_0_array[0, 0, 0] = 1.0  # (0,0) real\n    sigma_0_array[1, 1, 0] = 1.0  # (1,1) real\n\n    # \u03c3\u2093 (sigma_x)\n    sigma_x_array = np.zeros((2, 2, 4))\n    sigma_x_array[0, 1, 0] = 1.0  # (0,1) real\n    sigma_x_array[1, 0, 0] = 1.0  # (1,0) real\n\n    # Convert to quaternion arrays (simplified approach)\n    sigma_0 = quaternion.as_quat_array(sigma_0_array)\n    sigma_x = quaternion.as_quat_array(sigma_x_array)\n\n    return sigma_0, sigma_x\n\nsigma_0, sigma_x = create_pauli_matrices()\n</code></pre>"},{"location":"examples/#visualization","title":"Visualization","text":"<pre><code>from quatica.visualization import Visualizer\n\n# Plot residual convergence\nVisualizer.plot_residuals(residuals, title=\"Newton-Schulz Convergence\")\n\n# Visualize matrix components\nVisualizer.visualize_matrix(A, component=0, title=\"Real Component\")  # w component\nVisualizer.visualize_matrix(A, component=1, title=\"i Component\")     # x component\n\n# Visualize absolute values\nVisualizer.visualize_matrix_abs(A, title=\"Matrix Absolute Values\")\n</code></pre>"},{"location":"examples/#matrix-generation","title":"Matrix Generation","text":"<pre><code>from quatica.data_gen import create_test_matrix, create_sparse_quat_matrix, generate_random_unitary_matrix\n\n# Random dense matrix\nA_dense = create_test_matrix(m=50, n=30, rank=20)\n\n# Sparse matrix\nA_sparse = create_sparse_quat_matrix(m=100, n=100, density=0.1)\n\n# Random unitary matrix\nU_unitary = generate_random_unitary_matrix(n=10)\n</code></pre>"},{"location":"examples/#performance-tips","title":"\ud83c\udfaf Performance Tips","text":""},{"location":"examples/#optimal-setup","title":"Optimal Setup","text":"<pre><code># Use numpy&gt;=2.3.2 for 10-15x speedup\npip install --upgrade \"numpy&gt;=2.3.2\"\n\n# Check your numpy version\npython -c \"import numpy; print(f'numpy: {numpy.__version__}')\"\n</code></pre>"},{"location":"examples/#choose-the-right-algorithm","title":"Choose the Right Algorithm","text":"<ul> <li>Small matrices (&lt;200): Standard algorithms</li> <li>Large matrices (\u2265200): Use LU-preconditioned Q-GMRES</li> <li>Pseudoinverse: Newton-Schulz for speed, Higher-Order NS for accuracy</li> <li>SVD: Classical for accuracy, randomized for speed on large matrices</li> </ul>"},{"location":"examples/#memory-optimization","title":"Memory Optimization","text":"<pre><code># For large matrices, use sparse representations when possible\nfrom quatica.utils import SparseQuaternionMatrix\n\n# Create sparse matrix instead of dense\nA_sparse = create_sparse_quat_matrix(1000, 1000, density=0.01)\n\n# Convert dense to sparse if mostly zeros\n# (implement conversion based on density threshold)\n</code></pre>"},{"location":"examples/#output-files","title":"\ud83d\udcca Output Files","text":"<p>All examples save results to:</p> <ul> <li><code>output_figures/</code>: Application plots and visualizations</li> <li><code>validation_output/</code>: Unit test validation figures</li> <li>Console output: Detailed analysis and metrics</li> </ul> <p>Results include PSNR/SSIM metrics for image processing and convergence analysis for iterative methods.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Complete setup guide for QuatIca - from installation to first successful run.</p>"},{"location":"getting-started/#quick-installation-2-minutes","title":"\ud83d\ude80 Quick Installation (2 minutes)","text":""},{"location":"getting-started/#step-1-create-virtual-environment","title":"Step 1: Create Virtual Environment","text":"<pre><code># Create virtual environment named 'quatica'\npython3 -m venv quatica\n\n# Activate it\nsource quatica/bin/activate   # Mac/Linux\n# Windows: quatica\\Scripts\\activate\n</code></pre>"},{"location":"getting-started/#step-2-install-dependencies","title":"Step 2: Install Dependencies","text":"<pre><code># Upgrade pip and install requirements\npip install -U pip wheel\npip install -r requirements.txt\n</code></pre> <p>Critical Performance Note</p> <p>numpy&gt;=2.3.2 is REQUIRED for optimal performance. numpy 2.3.2 provides 10-15x speedup for quaternion matrix operations compared to older versions.</p>"},{"location":"getting-started/#step-3-verify-installation","title":"Step 3: Verify Installation","text":"<pre><code># Check numpy version (should be \u22652.3.2)\npython -c \"import numpy; print(f'numpy: {numpy.__version__}')\"\n\n# Test QuatIca\npython run_analysis.py\n</code></pre>"},{"location":"getting-started/#first-examples","title":"\ud83c\udfaf First Examples","text":""},{"location":"getting-started/#learn-the-framework","title":"Learn the Framework","text":"<pre><code># Start here - interactive tutorial with visualizations\npython run_analysis.py tutorial\n</code></pre> <p>This command runs the complete QuatIca tutorial covering:</p> <ul> <li>Quaternion matrix basics</li> <li>Matrix operations and norms</li> <li>Pseudoinverse computation</li> <li>Linear system solving</li> <li>Performance analysis</li> </ul>"},{"location":"getting-started/#test-core-functionality","title":"Test Core Functionality","text":"<pre><code># Test Q-GMRES solver\npython run_analysis.py qgmres\n\n# Test image processing\npython run_analysis.py image_completion\n</code></pre>"},{"location":"getting-started/#system-requirements","title":"\ud83d\udccb System Requirements","text":""},{"location":"getting-started/#minimum-requirements","title":"Minimum Requirements","text":"<ul> <li>Python: 3.9 or higher</li> <li>OS: macOS, Linux, or Windows</li> <li>RAM: 4 GB (8+ GB recommended)</li> <li>Storage: 1 GB free space</li> </ul>"},{"location":"getting-started/#recommended-setup","title":"Recommended Setup","text":"<ul> <li>Python: 3.10-3.12 (best wheel availability)</li> <li>RAM: 16 GB for large matrix operations</li> <li>CPU: Multi-core for parallel operations</li> </ul>"},{"location":"getting-started/#platform-specific-notes","title":"\ud83d\udd27 Platform-Specific Notes","text":""},{"location":"getting-started/#windows-users","title":"Windows Users","text":"<ol> <li>Enable Long Path Support: Required for deep directory structures</li> <li>Keep repo path short: Use <code>C:\\src\\QuatIca</code> instead of deep paths</li> <li>Python version: Prefer 3.10-3.12 for best wheel availability</li> </ol>"},{"location":"getting-started/#optional-pytorch-installation","title":"Optional PyTorch Installation","text":"<p>If you need PyTorch for advanced features:</p> <pre><code># CPU version\npip install torch torchvision --index-url https://download.pytorch.org/whl/cpu\n\n# CUDA 12.1 version\npip install torch torchvision --index-url https://download.pytorch.org/whl/cu121\n</code></pre>"},{"location":"getting-started/#verification-steps","title":"\ud83e\uddea Verification Steps","text":"<p>Run these commands to ensure everything works correctly:</p>"},{"location":"getting-started/#1-check-dependencies","title":"1. Check Dependencies","text":"<pre><code>python -c \"import numpy, quaternion, scipy, matplotlib; print('All core dependencies loaded successfully')\"\n</code></pre>"},{"location":"getting-started/#2-test-basic-operations","title":"2. Test Basic Operations","text":"<pre><code>python -c \"\nimport numpy as np\nimport quaternion\nfrom quatica.utils import quat_matmat, quat_frobenius_norm\nA = quaternion.as_quat_array(np.random.randn(3, 3, 4))\nB = quaternion.as_quat_array(np.random.randn(3, 3, 4))\nC = quat_matmat(A, B)\nnorm = quat_frobenius_norm(C)\nprint(f'Matrix multiplication successful, norm: {norm:.6f}')\n\"\n</code></pre>"},{"location":"getting-started/#3-run-complete-tutorial","title":"3. Run Complete Tutorial","text":"<pre><code>python run_analysis.py tutorial\n</code></pre> <p>Expected: Generates 7+ visualization files in <code>output_figures/</code> directory.</p>"},{"location":"getting-started/#project-layout-understanding","title":"\ud83d\udcc1 Project Layout Understanding","text":"<p>Once installed, familiarize yourself with the structure:</p> <pre><code>QuatIca/\n\u251c\u2500\u2500 quatica/                   # Core library functions\n\u2502   \u251c\u2500\u2500 utils.py           # Quaternion matrix operations\n\u2502   \u251c\u2500\u2500 solver.py          # Pseudoinverse, Q-GMRES solvers\n\u2502   \u251c\u2500\u2500 decomp/            # Matrix decompositions (QR, SVD, LU, etc.)\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 tests/                 # Test suites and validation\n\u251c\u2500\u2500 applications/          # Real-world applications\n\u251c\u2500\u2500 output_figures/        # Generated plots (auto-created)\n\u251c\u2500\u2500 validation_output/     # Test validation figures (auto-created)\n\u2514\u2500\u2500 run_analysis.py       # Main script runner\n</code></pre>"},{"location":"getting-started/#next-steps","title":"\ud83c\udfaf Next Steps","text":""},{"location":"getting-started/#for-beginners","title":"For Beginners","text":"<ol> <li>Run the tutorial: <code>python run_analysis.py tutorial</code></li> <li>Explore examples: See Examples page</li> <li>Try image processing: <code>python run_analysis.py image_completion</code></li> </ol>"},{"location":"getting-started/#for-developers","title":"For Developers","text":"<ol> <li>Examine the API: Browse API Documentation</li> <li>Study decompositions: Check Matrix Decompositions</li> <li>Run unit tests: <code>python -m pytest tests/unit/ -v</code></li> </ol>"},{"location":"getting-started/#for-researchers","title":"For Researchers","text":"<ol> <li>Benchmark performance: <code>python run_analysis.py lorenz_benchmark</code></li> <li>Test Schur decomposition: <code>python run_analysis.py schur_demo</code></li> <li>Explore signal processing: <code>python run_analysis.py lorenz_signal</code></li> </ol>"},{"location":"getting-started/#troubleshooting","title":"\ud83d\udd0d Troubleshooting","text":""},{"location":"getting-started/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/#command-not-found-python","title":"\"Command not found: python\"","text":"<pre><code># Try python3 instead\npython3 --version\n\n# Or install Python from python.org\n</code></pre>"},{"location":"getting-started/#numpy-version-too-old","title":"\"numpy version too old\"","text":"<pre><code># Upgrade numpy\npip install --upgrade \"numpy&gt;=2.3.2\"\n\n# Verify version\npython -c \"import numpy; print(numpy.__version__)\"\n</code></pre>"},{"location":"getting-started/#import-error","title":"\"Import error\"","text":"<pre><code># Make sure virtual environment is activated\nsource quatica/bin/activate  # Mac/Linux\n# Windows: quatica\\Scripts\\activate\n\n# Should see (quatica) in your prompt\n</code></pre>"},{"location":"getting-started/#permission-denied","title":"\"Permission denied\"","text":"<pre><code># Use virtual environment (recommended)\npython3 -m venv quatica\nsource quatica/bin/activate\n\n# Or add --user flag\npip install --user -r requirements.txt\n</code></pre>"},{"location":"getting-started/#slow-performance","title":"\"Slow performance\"","text":"<ul> <li>Check numpy version: Must be \u22652.3.2</li> <li>Avoid problematic packages: opencv-python and tqdm cause 3x slowdown</li> <li>Use recommended hardware: 16GB RAM, multi-core CPU</li> </ul>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<ol> <li>Check examples: Comprehensive examples in Examples</li> <li>Review API docs: Complete function reference in API section</li> <li>File issues: GitHub Issues</li> <li>Contact: v dot leplat [at] innopolis dot ru</li> </ol>"},{"location":"getting-started/#success-indicators","title":"\u2705 Success Indicators","text":"<p>You're ready to use QuatIca when:</p> <ul> <li>\u2705 Virtual environment is activated (see <code>(quatica)</code> in prompt)</li> <li>\u2705 numpy version \u22652.3.2 installed</li> <li>\u2705 <code>python run_analysis.py tutorial</code> completes successfully</li> <li>\u2705 Visualization files appear in <code>output_figures/</code> directory</li> <li>\u2705 No import errors when running examples</li> </ul> <p>\ud83c\udf89 Congratulations! You're now ready to explore quaternion linear algebra with QuatIca.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and solutions for QuatIca setup and usage.</p>"},{"location":"troubleshooting/#installation-issues","title":"\ud83d\udd27 Installation Issues","text":""},{"location":"troubleshooting/#command-not-found-python","title":"\"Command not found: python\"","text":"<p>Problem: Python is not installed or not in PATH.</p> <p>Solutions:</p> <pre><code># Try python3 instead\npython3 --version\n\n# Install Python from python.org\n# Download Python 3.9+ from https://python.org\n\n# On macOS with Homebrew\nbrew install python\n\n# On Ubuntu/Debian\nsudo apt update &amp;&amp; sudo apt install python3 python3-pip\n\n# On Windows: Download from python.org and check \"Add to PATH\"\n</code></pre>"},{"location":"troubleshooting/#pip-command-not-found","title":"\"pip: command not found\"","text":"<p>Problem: pip is not installed or not accessible.</p> <p>Solutions:</p> <pre><code># Use python -m pip instead\npython -m pip --version\n\n# Install pip manually\npython -m ensurepip --upgrade\n\n# On Ubuntu/Debian\nsudo apt install python3-pip\n</code></pre>"},{"location":"troubleshooting/#permission-denied-when-installing-packages","title":"\"Permission denied\" when installing packages","text":"<p>Problem: Trying to install to system Python without permissions.</p> <p>Solutions:</p> <pre><code># Use virtual environment (RECOMMENDED)\npython3 -m venv quatica\nsource quatica/bin/activate  # Mac/Linux\n# Windows: quatica\\Scripts\\activate\n\n# Then install normally\npip install -r requirements.txt\n\n# Alternative: Install for user only\npip install --user -r requirements.txt\n</code></pre>"},{"location":"troubleshooting/#performance-issues","title":"\u26a1 Performance Issues","text":""},{"location":"troubleshooting/#slow-performance-numpy-version","title":"\"Slow performance\" - numpy version","text":"<p>Problem: Using old numpy version (significant performance impact).</p> <p>Diagnosis:</p> <pre><code># Check numpy version\npython -c \"import numpy; print(f'numpy version: {numpy.__version__}')\"\n</code></pre> <p>Solution:</p> <pre><code># Upgrade to numpy&gt;=2.3.2 (CRITICAL for performance)\npip install --upgrade \"numpy&gt;=2.3.2\"\n\n# Verify upgrade\npython -c \"import numpy; print(f'numpy version: {numpy.__version__}')\"\n</code></pre> <p>Performance Impact</p> <p>numpy 2.3.2 provides 10-15x speedup for quaternion operations compared to version 2.2.6. Using older versions will result in dramatically slower performance.</p>"},{"location":"troubleshooting/#memory-error-during-computation","title":"\"Memory error\" during computation","text":"<p>Problem: Insufficient RAM for large matrix operations.</p> <p>Solutions:</p> <pre><code># Use smaller problem sizes\npython run_analysis.py lorenz_signal --num_points 100  # Instead of 500\n\n# For image processing, use smaller images\npython run_analysis.py image_deblurring --size 32  # Instead of 128\n\n# Close other applications to free RAM\n# Consider upgrading to 16GB+ RAM for large problems\n</code></pre>"},{"location":"troubleshooting/#slow-performance-with-certain-packages","title":"Slow performance with certain packages","text":"<p>Problem: opencv-python and tqdm cause 3x performance degradation.</p> <p>Diagnosis:</p> <pre><code># Check if problematic packages are installed\npip list | grep opencv\npip list | grep tqdm\n</code></pre> <p>Solution:</p> <pre><code># Remove if not needed\npip uninstall opencv-python tqdm\n\n# Or create clean environment\npython3 -m venv quatica_clean\nsource quatica_clean/bin/activate\npip install -r requirements.txt  # Only core dependencies\n</code></pre>"},{"location":"troubleshooting/#import-and-path-issues","title":"\ud83d\udd0d Import and Path Issues","text":""},{"location":"troubleshooting/#modulenotfounderror-for-core-modules","title":"\"ModuleNotFoundError\" for core modules","text":"<p>Problem: Python can't find QuatIca core modules.</p> <p>Diagnosis:</p> <pre><code># Check if you're in the right directory\npwd\nls  # Should see run_analysis.py, quatica/, tests/, etc.\n\n# Check if virtual environment is activated\necho $VIRTUAL_ENV  # Should show path to quatica environment\n</code></pre> <p>Solutions:</p> <pre><code># Make sure you're in the QuatIca directory\ncd /path/to/QuatIca\n\n# Activate virtual environment\nsource quatica/bin/activate  # Mac/Linux\n# Windows: quatica\\Scripts\\activate\n\n# Should see (quatica) in your prompt\n\n# Test import\npython -c \"from quatica.utils import quat_matmat; print('Import successful')\"\n</code></pre>"},{"location":"troubleshooting/#importerror-for-quaternion","title":"\"ImportError\" for quaternion","text":"<p>Problem: numpy-quaternion not installed properly.</p> <p>Solutions:</p> <pre><code># Install quaternion library\npip install numpy-quaternion\n\n# Or upgrade if installed\npip install --upgrade numpy-quaternion\n\n# Test\npython -c \"import quaternion; print('Quaternion library working')\"\n</code></pre>"},{"location":"troubleshooting/#script-execution-issues","title":"\ud83d\udcca Script Execution Issues","text":""},{"location":"troubleshooting/#script-not-found-errors","title":"\"Script not found\" errors","text":"<p>Problem: Scripts can't be found or executed.</p> <p>Solutions:</p> <pre><code># Always run from QuatIca root directory\ncd /path/to/QuatIca\n\n# Use the runner script (RECOMMENDED)\npython run_analysis.py tutorial\n\n# If running scripts directly, use full paths\npython tests/tutorial_quaternion_basics.py\npython applications/image_completion/script_real_image_completion.py\n</code></pre>"},{"location":"troubleshooting/#no-output-figures-generated","title":"No output figures generated","text":"<p>Problem: Figures not being saved or displayed.</p> <p>Diagnosis:</p> <pre><code># Check if output_figures directory exists\nls -la | grep output_figures\n\n# Check matplotlib backend\npython -c \"import matplotlib; print(f'Backend: {matplotlib.get_backend()}')\"\n</code></pre> <p>Solutions:</p> <pre><code># Create output directory if missing\nmkdir -p output_figures validation_output\n\n# Test matplotlib\npython -c \"\nimport matplotlib.pyplot as plt\nimport numpy as np\nplt.plot([1,2,3])\nplt.savefig('test_plot.png')\nprint('Matplotlib working, test_plot.png created')\n\"\n\n# For headless systems, set backend\nexport MPLBACKEND=Agg\npython run_analysis.py tutorial\n</code></pre>"},{"location":"troubleshooting/#quaternion-visualization-issues","title":"Quaternion visualization issues","text":"<p>Problem: Quaternion components not displaying correctly.</p> <p>Solutions:</p> <pre><code># Test basic quaternion operations\npython -c \"\nimport numpy as np\nimport quaternion\nfrom quatica.utils import quat_frobenius_norm\nA = quaternion.as_quat_array(np.random.randn(3, 3, 4))\nprint(f'Matrix shape: {A.shape}')\nprint(f'Norm: {quat_frobenius_norm(A):.6f}')\nprint('Quaternion operations working')\n\"\n</code></pre>"},{"location":"troubleshooting/#testing-issues","title":"\ud83e\uddea Testing Issues","text":""},{"location":"troubleshooting/#unit-tests-failing","title":"Unit tests failing","text":"<p>Problem: Tests not passing when run manually.</p> <p>Diagnosis:</p> <pre><code># Run specific test with verbose output\npython -m pytest tests/unit/test_basic_algebra.py -v\n\n# Check test environment\npython -c \"\nimport sys\nprint(f'Python version: {sys.version}')\nprint(f'Python path: {sys.path[:3]}...')\n\"\n</code></pre> <p>Solutions:</p> <pre><code># Make sure you're in the right environment and directory\nsource quatica/bin/activate\ncd /path/to/QuatIca\n\n# Run tests with proper path\npython -m pytest tests/decomp/test_qsvd.py -v\n\n# For single test files\npython tests/unit/test_basic_algebra.py\n</code></pre>"},{"location":"troubleshooting/#q-gmres-convergence-issues","title":"Q-GMRES convergence issues","text":"<p>Problem: Q-GMRES solver not converging or giving poor results.</p> <p>Solutions:</p> <pre><code># Try with LU preconditioning\npython -c \"\nfrom quatica.solver import QGMRESSolver\nsolver = QGMRESSolver(preconditioner='left_lu', verbose=True)\n# Use solver...\n\"\n\n# Increase iteration limit\npython -c \"\nsolver = QGMRESSolver(max_iter=200, tol=1e-8)\n# Use solver...\n\"\n\n# Check matrix conditioning\npython -c \"\nimport numpy as np\nfrom quatica.utils import matrix_norm\n# Check condition number of your matrix\nprint(f'Matrix 1-norm: {matrix_norm(A, 1)}')\nprint(f'Matrix inf-norm: {matrix_norm(A, np.inf)}')\n\"\n</code></pre>"},{"location":"troubleshooting/#common-errors-and-fixes","title":"\ud83d\udc1b Common Errors and Fixes","text":""},{"location":"troubleshooting/#segmentation-fault-or-crashes","title":"\"Segmentation fault\" or crashes","text":"<p>Problem: Usually related to numpy/BLAS configuration.</p> <p>Solutions:</p> <pre><code># Update numpy and dependencies\npip install --upgrade numpy scipy\n\n# Try different BLAS library\npip uninstall numpy\npip install numpy --no-binary numpy  # Compile from source\n\n# Check for conflicting packages\npip list | grep -E \"(mkl|openblas|atlas)\"\n</code></pre>"},{"location":"troubleshooting/#runtimewarning-about-matrix-inversion","title":"\"RuntimeWarning\" about matrix inversion","text":"<p>Problem: Ill-conditioned matrices causing numerical warnings.</p> <p>Solutions:</p> <pre><code># Use regularization for better conditioning\npython -c \"\nfrom quatica.solver import NewtonSchulzPseudoinverse\nsolver = NewtonSchulzPseudoinverse(gamma=0.5)  # Damping\n# This improves stability for ill-conditioned matrices\n\"\n\n# For Q-GMRES, use preconditioning\npython -c \"\nfrom quatica.solver import QGMRESSolver\nsolver = QGMRESSolver(preconditioner='left_lu')\n\"\n</code></pre>"},{"location":"troubleshooting/#deprecationwarning-messages","title":"\"DeprecationWarning\" messages","text":"<p>Problem: Harmless warnings from seaborn or other libraries.</p> <p>Solution:</p> <pre><code># These warnings are normal and don't affect functionality\n# To suppress warnings (optional):\npython -W ignore run_analysis.py tutorial\n\n# Or in Python:\nimport warnings\nwarnings.filterwarnings('ignore')\n</code></pre>"},{"location":"troubleshooting/#environment-issues","title":"\ud83d\udd27 Environment Issues","text":""},{"location":"troubleshooting/#virtual-environment-problems","title":"Virtual environment problems","text":"<p>Problem: Environment not working correctly.</p> <p>Solutions:</p> <pre><code># Recreate environment from scratch\nrm -rf quatica  # Remove old environment\npython3 -m venv quatica\nsource quatica/bin/activate\npip install --upgrade pip wheel\npip install -r requirements.txt\n\n# Verify environment\nwhich python  # Should point to quatica/bin/python\npip list | head -10\n</code></pre>"},{"location":"troubleshooting/#windows-specific-issues","title":"Windows-specific issues","text":"<p>Common Windows problems and solutions:</p> <pre><code># Long path support\n# Enable in Group Policy: Computer Configuration &gt; Administrative Templates &gt; System &gt; Filesystem &gt; Enable Win32 long paths\n\n# PowerShell execution policy\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n\n# Use forward slashes in paths\ncd C:/src/QuatIca  # Instead of C:\\src\\QuatIca\n\n# Activate environment on Windows\nquatica\\Scripts\\activate.bat  # CMD\nquatica\\Scripts\\Activate.ps1  # PowerShell\n</code></pre>"},{"location":"troubleshooting/#getting-help","title":"\ud83d\udcde Getting Help","text":""},{"location":"troubleshooting/#before-asking-for-help","title":"Before asking for help","text":"<ol> <li>Check this troubleshooting guide first</li> <li>Verify your setup:    <pre><code>python --version  # Should be 3.9+\npython -c \"import numpy; print(numpy.__version__)\"  # Should be \u22652.3.2\nsource quatica/bin/activate  # Environment active?\n</code></pre></li> <li>Run the tutorial: <code>python run_analysis.py tutorial</code></li> <li>Check for error messages in the console output</li> </ol>"},{"location":"troubleshooting/#provide-this-information-when-asking-for-help","title":"Provide this information when asking for help","text":"<pre><code># System information\necho \"OS: $(uname -a)\"\npython --version\npython -c \"import numpy, quaternion, scipy; print(f'numpy: {numpy.__version__}, quaternion: {quaternion.__version__}, scipy: {scipy.__version__}')\"\npip list | grep -E \"(numpy|quaternion|scipy|matplotlib)\"\n\n# Error reproduction\npython run_analysis.py tutorial 2&gt;&amp;1 | tee error_log.txt\n</code></pre>"},{"location":"troubleshooting/#contact-and-support","title":"Contact and Support","text":"<ul> <li>GitHub Issues: https://github.com/vleplat/QuatIca/issues</li> <li>Email: v dot leplat [at] innopolis dot ru</li> <li>Documentation: This site and inline code documentation</li> </ul>"},{"location":"troubleshooting/#useful-debugging-commands","title":"Useful debugging commands","text":"<pre><code># Test core functionality\npython -c \"\nimport numpy as np\nimport quaternion\nfrom quatica.utils import quat_matmat, quat_frobenius_norm\nfrom quatica.solver import NewtonSchulzPseudoinverse\n\nprint('Testing core functionality...')\nA = quaternion.as_quat_array(np.random.randn(4, 4, 4))\nnorm = quat_frobenius_norm(A)\nprint(f'\u2713 Matrix norm: {norm:.6f}')\n\nsolver = NewtonSchulzPseudoinverse()\nA_pinv, _, _ = solver.compute(A)\nprint(f'\u2713 Pseudoinverse computed, shape: {A_pinv.shape}')\nprint('All core functions working!')\n\"\n\n# Test plotting\npython -c \"\nimport matplotlib.pyplot as plt\nimport numpy as np\nplt.figure()\nplt.plot([1,2,3,4], [1,4,2,3])\nplt.savefig('test_plot.png')\nprint('\u2713 Plotting works, test_plot.png created')\n\"\n</code></pre> <p>Remember: Most issues are related to environment setup, numpy version, or running from the wrong directory. Double-check these basics first!</p>"},{"location":"api/data_gen/","title":"quatica.data_gen","text":""},{"location":"api/data_gen/#quatica.data_gen","title":"<code>quatica.data_gen</code>","text":""},{"location":"api/data_gen/#quatica.data_gen.create_sparse_quat_matrix","title":"<code>create_sparse_quat_matrix(m, n, density=0.1)</code>","text":"<p>Create a random sparse quaternion matrix of size m\u00d7n using CSR format.</p> <p>Generates a sparse quaternion matrix with random entries distributed according to the specified density. Each quaternion component (real, i, j, k) is stored as a separate CSR sparse matrix for efficient computation.</p>"},{"location":"api/data_gen/#quatica.data_gen.create_sparse_quat_matrix--parameters","title":"Parameters:","text":"<p>m : int     Number of rows in the matrix n : int     Number of columns in the matrix density : float, optional     Density of non-zero elements (between 0 and 1) (default: 0.1)</p>"},{"location":"api/data_gen/#quatica.data_gen.create_sparse_quat_matrix--returns","title":"Returns:","text":"<p>SparseQuaternionMatrix     A sparse quaternion matrix with random entries stored in CSR format</p>"},{"location":"api/data_gen/#quatica.data_gen.create_sparse_quat_matrix--notes","title":"Notes:","text":"<p>The sparse format is particularly efficient for large matrices with low density. Each quaternion component is stored separately to optimize sparse matrix operations.</p>"},{"location":"api/data_gen/#quatica.data_gen.create_test_matrix","title":"<code>create_test_matrix(m, n, rank=None, cond_number=None)</code>","text":"<p>Generate a random dense quaternion matrix with optional rank and conditioning.</p> <p>Creates a quaternion matrix by multiplying two factor matrices A (m\u00d7rank) and B (rank\u00d7n). This ensures the resulting matrix has exactly the specified rank. Optional conditioning can be applied to control the singular value distribution.</p>"},{"location":"api/data_gen/#quatica.data_gen.create_test_matrix--parameters","title":"Parameters:","text":"<p>m : int     Number of rows in the output matrix n : int     Number of columns in the output matrix rank : int, optional     Desired rank of the matrix (default: min(m, n)) cond_number : float, optional     Condition number for the matrix (default: None, no conditioning applied)</p>"},{"location":"api/data_gen/#quatica.data_gen.create_test_matrix--returns","title":"Returns:","text":"<p>np.ndarray     An m\u00d7n quaternion matrix with the specified rank and conditioning</p>"},{"location":"api/data_gen/#quatica.data_gen.create_test_matrix--notes","title":"Notes:","text":"<p>The matrix is generated as A @ B where A is m\u00d7rank and B is rank\u00d7n. When cond_number is specified, singular values are distributed logarithmically from 1 to 1/cond_number to achieve the desired conditioning.</p>"},{"location":"api/data_gen/#quatica.data_gen.generate_random_unitary_matrix","title":"<code>generate_random_unitary_matrix(n)</code>","text":"<p>Generate a random unitary quaternion matrix of size n\u00d7n.</p> <p>This function creates a random unitary matrix by: 1. Generating a random n\u00d7n quaternion matrix 2. Computing its QR decomposition 3. Returning the Q matrix, which is guaranteed to be unitary</p>"},{"location":"api/data_gen/#quatica.data_gen.generate_random_unitary_matrix--parameters","title":"Parameters:","text":"<p>n : int     Size of the square unitary matrix to generate</p>"},{"location":"api/data_gen/#quatica.data_gen.generate_random_unitary_matrix--returns","title":"Returns:","text":"<p>np.ndarray     An n\u00d7n unitary quaternion matrix Q satisfying Q^H * Q = I</p>"},{"location":"api/data_gen/#quatica.data_gen.generate_random_unitary_matrix--notes","title":"Notes:","text":"<p>The generated matrix is truly unitary (orthogonal in quaternion space) and can be used for various applications including: - Random rotations in 4D space - Unitary transformations - Orthogonal basis generation - Testing unitary matrix algorithms</p>"},{"location":"api/data_gen/#quatica.data_gen.small_test_Mat","title":"<code>small_test_Mat()</code>","text":"<p>Create a validation quaternion matrix with known theoretical properties.</p> <p>This function returns a specific 2\u00d73 quaternion matrix that serves as a validation test for our pseudoinverse implementation. The matrix has known theoretical properties that allow us to verify the correctness of our numerical algorithms.</p> <p>The matrix corresponds to Example 5.2 from the reference paper:</p> <p>A = [1  i+2k  3]     [i  6+j   7]</p> <p>The theoretical pseudoinverse A^\u2020 (computed using Maple package) is: \u239b -47/347 + 21/694 i + 11/694 j - 21/694 k    63/347 - 28/347 i + 21/694 j - 101/694 k \u239e \u239c -11/694 - 347 i - 11/694 k                   61/694 + 21/694 i - 6/347 j + 21/347 k  \u239f \u239d  57/347 + 49/694 i + 77/694 k                21/347 - 21/694 i - 33/694 k            \u23a0</p>"},{"location":"api/data_gen/#quatica.data_gen.small_test_Mat--returns","title":"Returns:","text":"<p>np.ndarray     A 2\u00d73 quaternion matrix for validation testing</p>"},{"location":"api/data_gen/#quatica.data_gen.small_test_Mat--notes","title":"Notes:","text":"<p>This matrix is designed to test the accuracy and convergence properties of quaternion pseudoinverse algorithms. It should converge quickly and achieve high numerical accuracy, with results closely matching the theoretical pseudoinverse from the paper.</p>"},{"location":"api/data_gen/#quatica.data_gen.small_test_Mat--references","title":"References:","text":"<p>[1] Huang, L., Wang, Q.-W., &amp; Zhang, Y. (2015). The Moore\u2013Penrose inverses     of matrices over quaternion polynomial rings. Linear Algebra and its     Applications, 475, 45-61. https://doi.org/10.1016/j.laa.2015.02.004</p> <pre><code>Example 5.2 provides the exact theoretical pseudoinverse for comparison.\n</code></pre>"},{"location":"api/data_gen/#quatica.data_gen.theoretical_pseudoinverse_example_5_2","title":"<code>theoretical_pseudoinverse_example_5_2()</code>","text":"<p>Compute the theoretical pseudoinverse from Example 5.2 of the reference paper.</p> <p>This function returns the exact theoretical pseudoinverse A^\u2020 for the matrix A = [1 i+2k 3; i 6+j 7] as computed using the Maple package in the paper.</p>"},{"location":"api/data_gen/#quatica.data_gen.theoretical_pseudoinverse_example_5_2--returns","title":"Returns:","text":"<p>np.ndarray     The 3\u00d72 theoretical pseudoinverse matrix</p>"},{"location":"api/data_gen/#quatica.data_gen.theoretical_pseudoinverse_example_5_2--notes","title":"Notes:","text":"<p>This provides the exact analytical solution for comparison with our numerical implementation. The values are computed using the exact fractions from the paper.</p>"},{"location":"api/data_gen/#quatica.data_gen.theoretical_pseudoinverse_example_5_2--references","title":"References:","text":"<p>[1] Huang, L., Wang, Q.-W., &amp; Zhang, Y. (2015). The Moore\u2013Penrose inverses     of matrices over quaternion polynomial rings. Linear Algebra and its     Applications, 475, 45-61. https://doi.org/10.1016/j.laa.2015.02.004</p>"},{"location":"api/qslst/","title":"quatica.qslst","text":""},{"location":"api/qslst/#quatica.qslst","title":"<code>quatica.qslst</code>","text":""},{"location":"api/qslst/#quatica.qslst--qslst-quaternion-special-least-squares-with-tikhonov-regularization","title":"QSLST: Quaternion Special Least Squares with Tikhonov Regularization","text":"<p>This module provides a practical implementation of Algorithm 2 (QSLST) from [1] for quaternion-valued image restoration. It follows the formulation</p> <pre><code>(A^T A + \u03bb I) X = A^T B,\n</code></pre> <p>where A is a real-valued blurring operator, X and B are quaternion images. For convolutional A (Gaussian/motion blur with periodic boundary), we exploit the diagonalization in the Fourier domain to obtain the closed-form Tikhonov solution. For a generic real matrix A, we provide a faithful pinv-based path that implements Algorithm 2 exactly without explicitly forming A(T) = A(A^T A + \u03bb I).</p>"},{"location":"api/qslst/#quatica.qslst--quaternion-representation","title":"Quaternion representation","text":"<p>We represent a quaternion image Q as a float array of shape (H, W, 4) whose last dimension stores components [q0, q1, q2, q3]. For RGB color, the common choice is q0 = 0, q1 = R, q2 = G, q3 = B. Use <code>rgb_to_quat</code> / <code>quat_to_rgb</code> helpers to convert.</p>"},{"location":"api/qslst/#quatica.qslst--core-api","title":"Core API","text":"<ul> <li> <p>qslst_restore_fft(Bq, psf, lam, boundary=\"periodic\")  -&gt; Xq     Efficient path for convolutional blur with periodic boundary (BCCB).</p> </li> <li> <p>qslst_restore_matrix(Bq, A_mat, lam) -&gt; Xq     Faithful Algorithm 2 using T = A^T A + lam I and pseudo-inverse of T.</p> </li> <li> <p>build_psf_gaussian(radius, sigma) -&gt; psf</p> </li> <li>build_psf_motion(length, angle_deg) -&gt; psf</li> <li>apply_blur_fft(Q, psf, boundary=\"periodic\") -&gt; blurred quaternion</li> <li>add_awgn_snr(Q, snr_db, rng=None) -&gt; noisy quaternion</li> <li>psnr(x, x_ref), relative_error(x, x_ref)</li> </ul> <p>All functions are fully numpy-based.</p>"},{"location":"api/qslst/#quatica.qslst--references","title":"References","text":"<p>[1] Fei, W., Tang, J., &amp; Shan, M.     Quaternion special least squares with Tikhonov regularization method in image restoration.     Numerical Algorithms, 1-20. (2025)     https://doi.org/10.1007/s11075-025-02187-6</p>"},{"location":"api/qslst/#quatica.qslst.add_awgn_snr","title":"<code>add_awgn_snr(Q, snr_db, rng=None)</code>","text":"<p>Add white Gaussian noise to reach a target SNR (in dB) per quaternion image.</p> <p>Adds calibrated noise to achieve a specific signal-to-noise ratio. SNR definition: SNR_dB = 10 * log10( ||signal||_F^2 / ||noise||_F^2 )</p>"},{"location":"api/qslst/#quatica.qslst.add_awgn_snr--parameters","title":"Parameters:","text":"<p>Q : np.ndarray     Clean quaternion image of shape (H, W, 4) snr_db : float     Target signal-to-noise ratio in decibels rng : np.random.Generator, optional     Random number generator (default: None, uses default_rng())</p>"},{"location":"api/qslst/#quatica.qslst.add_awgn_snr--returns","title":"Returns:","text":"<p>np.ndarray     Noisy quaternion image of shape (H, W, 4)</p>"},{"location":"api/qslst/#quatica.qslst.add_awgn_snr--notes","title":"Notes:","text":"<p>The noise variance is computed to achieve the exact target SNR. Returns the original image unchanged if signal power is zero.</p>"},{"location":"api/qslst/#quatica.qslst.apply_blur_fft","title":"<code>apply_blur_fft(Q, psf, boundary='periodic')</code>","text":"<p>Convolve quaternion image with PSF using FFT (per channel).</p> <p>Applies blurring to a quaternion image by convolving each quaternion component independently with the given point spread function using FFT.</p>"},{"location":"api/qslst/#quatica.qslst.apply_blur_fft--parameters","title":"Parameters:","text":"<p>Q : np.ndarray     Quaternion image array of shape (H, W, 4) psf : np.ndarray     Point spread function kernel of shape (kH, kW) boundary : str, optional     Boundary condition, only \"periodic\" is supported for BCCB (default: \"periodic\")</p>"},{"location":"api/qslst/#quatica.qslst.apply_blur_fft--returns","title":"Returns:","text":"<p>np.ndarray     Blurred quaternion image of shape (H, W, 4)</p>"},{"location":"api/qslst/#quatica.qslst.apply_blur_fft--notes","title":"Notes:","text":"<p>Uses FFT-based convolution for computational efficiency. Each quaternion component is convolved independently, preserving quaternion structure.</p>"},{"location":"api/qslst/#quatica.qslst.build_psf_gaussian","title":"<code>build_psf_gaussian(radius, sigma)</code>","text":"<p>Isotropic Gaussian PSF, truncated to a (2*radius+1) window and normalized.</p> <p>Creates a 2D Gaussian point spread function for image blurring operations. The PSF is truncated to a square window and normalized to unit sum.</p>"},{"location":"api/qslst/#quatica.qslst.build_psf_gaussian--parameters","title":"Parameters:","text":"<p>radius : int     Truncation radius r (PSF size will be 2*radius + 1) sigma : float     Standard deviation of the Gaussian distribution</p>"},{"location":"api/qslst/#quatica.qslst.build_psf_gaussian--returns","title":"Returns:","text":"<p>np.ndarray     Gaussian PSF array of shape (K, K) where K = 2*radius + 1, with sum(psf) = 1</p>"},{"location":"api/qslst/#quatica.qslst.build_psf_gaussian--notes","title":"Notes:","text":"<p>Uses the 2D Gaussian formula: exp(-(x\u00b2 + y\u00b2) / (2\u03c3\u00b2)) / (2\u03c0\u03c3\u00b2) The PSF is centered and normalized for convolution operations.</p>"},{"location":"api/qslst/#quatica.qslst.build_psf_motion","title":"<code>build_psf_motion(length, angle_deg)</code>","text":"<p>Simple linear motion blur PSF of given length and angle, normalized.</p> <p>Creates a motion blur kernel representing linear movement during exposure. The PSF models uniform motion along a straight line.</p>"},{"location":"api/qslst/#quatica.qslst.build_psf_motion--parameters","title":"Parameters:","text":"<p>length : int     Number of pixels in the motion kernel (&gt;= 1) angle_deg : float     Motion angle in degrees measured counter-clockwise from +x axis</p>"},{"location":"api/qslst/#quatica.qslst.build_psf_motion--returns","title":"Returns:","text":"<p>np.ndarray     Motion blur PSF array of shape (K, K) with sum = 1, where K is chosen     to tightly contain the motion line</p>"},{"location":"api/qslst/#quatica.qslst.build_psf_motion--notes","title":"Notes:","text":"<p>The kernel size K is automatically determined to contain the motion path. Points along the line are sampled uniformly and rounded to pixel positions.</p>"},{"location":"api/qslst/#quatica.qslst.psnr","title":"<code>psnr(x, x_ref, data_range=None)</code>","text":"<p>Peak Signal-to-Noise Ratio for arrays with same shape.</p> <p>Computes PSNR = 10 * log10(data_range\u00b2 / MSE) where MSE is the mean squared error. Higher values indicate better image quality/reconstruction.</p>"},{"location":"api/qslst/#quatica.qslst.psnr--parameters","title":"Parameters:","text":"<p>x : np.ndarray     Estimated/reconstructed array x_ref : np.ndarray     Reference/ground truth array data_range : float, optional     Dynamic range of the data (default: None, uses max(x_ref) - min(x_ref))</p>"},{"location":"api/qslst/#quatica.qslst.psnr--returns","title":"Returns:","text":"<p>float     PSNR value in decibels, or infinity if MSE is zero</p>"},{"location":"api/qslst/#quatica.qslst.psnr--notes","title":"Notes:","text":"<p>Standard metric for image quality assessment. Values typically range from 20-50 dB for natural images, with higher values indicating better quality.</p>"},{"location":"api/qslst/#quatica.qslst.qslst_restore_fft","title":"<code>qslst_restore_fft(Bq, psf, lam, boundary='periodic')</code>","text":"<p>QSLST (Algorithm 2) specialized to convolutional A with periodic BC.</p> <p>Implements the FFT-based Tikhonov solution for quaternion image restoration with convolutional blur operators. Per-channel closed-form solution: X_hat = conj(H_hat) * B_hat / (|H_hat|^2 + lam)</p>"},{"location":"api/qslst/#quatica.qslst.qslst_restore_fft--parameters","title":"Parameters:","text":"<p>Bq : np.ndarray     Observed blurred+noisy quaternion image of shape (H, W, 4) psf : np.ndarray     Point spread function of shape (kH, kW) lam : float     Tikhonov regularization parameter (&gt;= 0) boundary : str, optional     Boundary condition, only \"periodic\" supported (default: \"periodic\")</p>"},{"location":"api/qslst/#quatica.qslst.qslst_restore_fft--returns","title":"Returns:","text":"<p>np.ndarray     Restored quaternion image of shape (H, W, 4)</p>"},{"location":"api/qslst/#quatica.qslst.qslst_restore_fft--notes","title":"Notes:","text":"<p>Efficient FFT-based implementation for BCCB (block-circulant with circulant blocks) operators. Each quaternion component is restored independently using the same frequency domain filter.</p>"},{"location":"api/qslst/#quatica.qslst.qslst_restore_matrix","title":"<code>qslst_restore_matrix(Bq, A_mat, lam)</code>","text":"<p>Faithful Algorithm 2 (QSLST) for a generic real matrix A.</p> Implements the matrix-based QSLST algorithm for non-convolutional operators <p>T = A^T A + lam I E = A^T B X = T^+ E   (Moore-Penrose pseudoinverse)</p> <p>Since A is real, T is real; then A(T) = I_4 \u2297 T, and A(T)^+ = I_4 \u2297 T^+. Therefore we can solve per quaternion component independently.</p>"},{"location":"api/qslst/#quatica.qslst.qslst_restore_matrix--parameters","title":"Parameters:","text":"<p>Bq : np.ndarray     Observed quaternion image of shape (H, W, 4) A_mat : np.ndarray     Real blur matrix of shape (N, N) where N = H*W lam : float     Tikhonov regularization parameter (&gt;= 0)</p>"},{"location":"api/qslst/#quatica.qslst.qslst_restore_matrix--returns","title":"Returns:","text":"<p>np.ndarray     Restored quaternion image of shape (H, W, 4)</p>"},{"location":"api/qslst/#quatica.qslst.qslst_restore_matrix--notes","title":"Notes:","text":"<p>General implementation that works with any real matrix A, not just convolutional operators. Uses pseudoinverse for robust solution even when the system is ill-conditioned.</p>"},{"location":"api/qslst/#quatica.qslst.quat_to_rgb","title":"<code>quat_to_rgb(q, clip=True)</code>","text":"<p>Convert quaternion image to RGB by taking imaginary parts [q1, q2, q3].</p> <p>Extracts RGB color channels from quaternion imaginary components, with optional intelligent clipping for normalized values.</p>"},{"location":"api/qslst/#quatica.qslst.quat_to_rgb--parameters","title":"Parameters:","text":"<p>q : np.ndarray     Quaternion image array of shape (H, W, 4) clip : bool, optional     Whether to clip RGB to [0, 1] if input appears normalized (default: True)</p>"},{"location":"api/qslst/#quatica.qslst.quat_to_rgb--returns","title":"Returns:","text":"<p>np.ndarray     RGB image of shape (H, W, 3)</p>"},{"location":"api/qslst/#quatica.qslst.quat_to_rgb--notes","title":"Notes:","text":"<p>Inverse operation of rgb_to_quat. The clipping heuristic checks if values are in range [-0.5, 1.5] to determine if normalization is appropriate.</p>"},{"location":"api/qslst/#quatica.qslst.relative_error","title":"<code>relative_error(x, x_ref)</code>","text":"<p>Relative Frobenius error: ||x - x_ref||_F / ||x_ref||_F.</p> <p>Computes the normalized error between two arrays using the Frobenius norm. This metric is scale-invariant and commonly used for restoration quality assessment.</p>"},{"location":"api/qslst/#quatica.qslst.relative_error--parameters","title":"Parameters:","text":"<p>x : np.ndarray     Estimated/reconstructed array x_ref : np.ndarray     Reference/ground truth array</p>"},{"location":"api/qslst/#quatica.qslst.relative_error--returns","title":"Returns:","text":"<p>float     Relative error value, or infinity if reference norm is zero</p>"},{"location":"api/qslst/#quatica.qslst.relative_error--notes","title":"Notes:","text":"<p>Values closer to 0 indicate better reconstruction quality. This metric is particularly useful for comparing restoration algorithms.</p>"},{"location":"api/qslst/#quatica.qslst.rgb_to_quat","title":"<code>rgb_to_quat(rgb, real_part=0.0)</code>","text":"<p>Convert an RGB image to quaternion form (H, W, 4).</p> <p>Maps RGB color channels to quaternion imaginary parts with configurable real component. Common choice: q0=real_part, q1=R, q2=G, q3=B.</p>"},{"location":"api/qslst/#quatica.qslst.rgb_to_quat--parameters","title":"Parameters:","text":"<p>rgb : np.ndarray     RGB image array of shape (H, W, 3) with values in [0, 1] or [0, 255] real_part : float, optional     Value for quaternion real component q0 (default: 0.0)</p>"},{"location":"api/qslst/#quatica.qslst.rgb_to_quat--returns","title":"Returns:","text":"<p>np.ndarray     Quaternion image of shape (H, W, 4) with [q0, q1, q2, q3] = [real_part, R, G, B]</p>"},{"location":"api/qslst/#quatica.qslst.rgb_to_quat--notes","title":"Notes:","text":"<p>This conversion enables processing RGB images as quaternion matrices for quaternion-based image restoration algorithms.</p>"},{"location":"api/qslst/#quatica.qslst.split_quat_channels","title":"<code>split_quat_channels(q)</code>","text":"<p>Split quaternion image into individual component channels.</p> <p>Separates a quaternion image into its four scalar components for independent processing or analysis.</p>"},{"location":"api/qslst/#quatica.qslst.split_quat_channels--parameters","title":"Parameters:","text":"<p>q : np.ndarray     Quaternion image array of shape (H, W, 4)</p>"},{"location":"api/qslst/#quatica.qslst.split_quat_channels--returns","title":"Returns:","text":"<p>tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]     Four channel arrays (q0, q1, q2, q3), each of shape (H, W)</p>"},{"location":"api/qslst/#quatica.qslst.split_quat_channels--notes","title":"Notes:","text":"<p>Useful for component-wise operations where quaternion channels need to be processed separately.</p>"},{"location":"api/qslst/#quatica.qslst.stack_quat_channels","title":"<code>stack_quat_channels(q0, q1, q2, q3)</code>","text":"<p>Stack scalar channels into quaternion image (H, W, 4).</p> <p>Combines four separate scalar channel arrays into a single quaternion image for quaternion matrix operations.</p>"},{"location":"api/qslst/#quatica.qslst.stack_quat_channels--parameters","title":"Parameters:","text":"<p>q0 : np.ndarray     Real component array of shape (H, W) q1 : np.ndarray     First imaginary component array of shape (H, W) q2 : np.ndarray     Second imaginary component array of shape (H, W) q3 : np.ndarray     Third imaginary component array of shape (H, W)</p>"},{"location":"api/qslst/#quatica.qslst.stack_quat_channels--returns","title":"Returns:","text":"<p>np.ndarray     Quaternion image of shape (H, W, 4)</p>"},{"location":"api/qslst/#quatica.qslst.stack_quat_channels--notes","title":"Notes:","text":"<p>Inverse operation of split_quat_channels. All input arrays must have the same spatial dimensions (H, W).</p>"},{"location":"api/solver/","title":"quatica.solver","text":""},{"location":"api/solver/#quatica.solver","title":"<code>quatica.solver</code>","text":""},{"location":"api/solver/#quatica.solver.CGNEQSolver","title":"<code>CGNEQSolver</code>","text":"<p>Conjugate Gradient on the Normal Equations (CGNE\u2013Q) to solve XA = I_n in matrix form.</p> <p>Minimizes f(X) = 1/2 || X A - I_n ||_F^2 with quaternion-native operations.</p> <ul> <li>Column case (full column rank): A in H^{m x n} with m &gt;= n</li> <li>Iterates stay in span{A^H} when initialized with X0 = alpha * A^H</li> <li>Converges to A^\u2020 as ||I_n - X_k A||_F -&gt; 0</li> </ul>"},{"location":"api/solver/#quatica.solver.CGNEQSolver.compute","title":"<code>compute(A)</code>","text":"<p>Compute pseudoinverse using Conjugate Gradient on Normal Equations (CGNE\u2013Q).</p> <p>Minimizes f(X) = 1/2 || X A - I_n ||_F^2 with quaternion-native operations. This method provides global convergence to the Moore-Penrose pseudoinverse by solving the normal equations via conjugate gradient.</p>"},{"location":"api/solver/#quatica.solver.CGNEQSolver.compute--parameters","title":"Parameters:","text":"<p>A : np.ndarray     Quaternion matrix of shape (m, n) with m &gt;= n (full column rank)</p>"},{"location":"api/solver/#quatica.solver.CGNEQSolver.compute--returns","title":"Returns:","text":"<p>tuple[np.ndarray, dict]     X : np.ndarray         Pseudoinverse of A, shape (n, m)     info : dict         Dictionary containing convergence information:         - 'iterations': Number of CG iterations performed         - 'residual_norms': List of relative residual norms per iteration         - 'iteration_times': List of CPU times per iteration         - 'total_time': Total computation time         - 'converged': Boolean indicating if convergence was achieved         - 'preconditioner_rank': Rank of preconditioner used (0 if none)</p>"},{"location":"api/solver/#quatica.solver.CGNEQSolver.compute--notes","title":"Notes:","text":"<ul> <li>Requires m &gt;= n (full column rank matrices)</li> <li>Initializes with X_0 = (1/||A||_F^2) * A^H to stay in span{A^H}</li> <li>Uses Fletcher-Reeves CG with exact line search</li> <li>Supports optional thin Nystr\u00f6m-type right preconditioning</li> <li>All operations are quaternion-native with no embeddings</li> <li>Converges to A^\u2020 as ||I_n - X_k A||_F -&gt; 0</li> <li>Per iteration: one A multiply and one A^H multiply</li> </ul>"},{"location":"api/solver/#quatica.solver.DeepLinearNewtonSchulz","title":"<code>DeepLinearNewtonSchulz</code>","text":"<p>Deep Linear Newton-Schulz solver for quaternion matrices.</p> <p>Implements the alternating gradient method for deep linear networks using proper Newton-Schulz updates for each layer individually.</p> <p>The method optimizes ||X * W_1 * ... * W_d - I||_F -&gt; min where each W_i is updated using the damped Newton-Schulz formula: W_i^(k+1) = W_i^(k) - \u03b3 * W_i^(k) * (hat_W * hat_X * W_i^(k) - I)</p>"},{"location":"api/solver/#quatica.solver.DeepLinearNewtonSchulz.compute","title":"<code>compute(X, layers)</code>","text":"<p>Compute deep linear decomposition using alternating Newton-Schulz updates.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Input quaternion matrix (n_samples x input_dim)</p> required <code>layers</code> <code>list[int]</code> <p>List of layer dimensions [d0, d1, ..., dk]     where d0 = input_dim, dk = output_dim</p> required <p>Returns:</p> Name Type Description <code>weights</code> <code>list[ndarray]</code> <p>List of optimized quaternion weight matrices</p> <code>residuals</code> <code>dict[str, list[float]]</code> <p>Dictionary of residual norms over iterations</p> <code>deviations</code> <code>list[float]</code> <p>List of total deviation norms over iterations</p>"},{"location":"api/solver/#quatica.solver.HigherOrderNewtonSchulzPseudoinverse","title":"<code>HigherOrderNewtonSchulzPseudoinverse</code>","text":"<p>Third-order Newton\u2013Schulz pseudoinverse solver (no damping).</p> <p>Iteration (T := X_k):   X_{k+1} = 3 T - 3 T A T + T (A T)^2</p> Initialization <p>T_0 = A^H / ||A||_F^2</p> Residuals tracked per iteration <p>E1 = ||A X A - A||_F E2 = ||X A X - X||_F E3 = ||(A X)^H - A X||_F E4 = ||(X A)^H - X A||_F</p>"},{"location":"api/solver/#quatica.solver.HybridRSPNewtonSchulz","title":"<code>HybridRSPNewtonSchulz</code>","text":"<p>Hybrid RSP-Q + NS (column variant): alternate T randomized sketch-and-project steps with one exact hyperpower (order p) step on the right residual.</p>"},{"location":"api/solver/#quatica.solver.HybridRSPNewtonSchulz--parameters","title":"Parameters","text":"<p>r : int     Sketch block size for RSP-Q phase p : int     Hyperpower order for NS step (e.g., 2, 4, 8) T : int     Number of RSP steps per cycle before one NS step tol : float     Stopping tolerance for proxy residual using test sketch Pi max_iter : int     Maximum total RSP steps (cycles*T bounded by this) verbose : bool     Verbose logging seed : int | None     RNG seed</p>"},{"location":"api/solver/#quatica.solver.HybridRSPNewtonSchulz.compute","title":"<code>compute(A)</code>","text":"<p>Compute pseudoinverse using hybrid RSP-Q + NS algorithm.</p> <p>Alternates T randomized sketch-and-project steps with one exact hyperpower (order p) step on the right residual. This combines the efficiency of randomized methods with the accuracy of exact Newton-Schulz iterations.</p>"},{"location":"api/solver/#quatica.solver.HybridRSPNewtonSchulz.compute--parameters","title":"Parameters:","text":"<p>A : np.ndarray     Quaternion matrix of shape (m, n) with m &gt;= n (full column rank)</p>"},{"location":"api/solver/#quatica.solver.HybridRSPNewtonSchulz.compute--returns","title":"Returns:","text":"<p>tuple[np.ndarray, dict]     X : np.ndarray         Pseudoinverse of A, shape (n, m)     info : dict         Dictionary containing convergence information:         - 'iterations_rsp': Number of RSP iterations performed         - 'residual_norms': List of residual norms after each cycle         - 'total_time': Total computation time         - 'converged': Boolean indicating if convergence was achieved         - 'r': Block size used for RSP steps         - 'p': Hyperpower order used for NS steps         - 'T': Number of RSP steps per cycle</p>"},{"location":"api/solver/#quatica.solver.HybridRSPNewtonSchulz.compute--notes","title":"Notes:","text":"<ul> <li>Currently supports only column variant (m &gt;= n)</li> <li>Initializes with X_0 = (1/||A||_F^2) * A^H</li> <li>Performs T RSP steps followed by one NS hyperpower step per cycle</li> <li>Monitors convergence using test sketch to avoid full residual computation</li> <li>Combines benefits of randomized efficiency and exact convergence</li> </ul>"},{"location":"api/solver/#quatica.solver.NewtonSchulzPseudoinverse","title":"<code>NewtonSchulzPseudoinverse</code>","text":"<p>Compute the Moore\u2013Penrose pseudoinverse of quaternion matrices via damped Newton\u2013Schulz.</p>"},{"location":"api/solver/#quatica.solver.QGMRESSolver","title":"<code>QGMRESSolver</code>","text":"<p>Quaternion Generalized Minimal Residual (Q-GMRES) solver.</p> <p>Implements the Q-GMRES algorithm for solving quaternion linear systems A * x = b, where A is a quaternion matrix and b is a quaternion vector.</p> <p>Based on the implementation by Zhigang Jia and Michael K. Ng: \"Structure Preserving Quaternion Generalized Minimal Residual Method\", SIMAX, 2021</p>"},{"location":"api/solver/#quatica.solver.QGMRESSolver.__init__","title":"<code>__init__(tol=1e-06, max_iter=None, verbose=False, preconditioner=None)</code>","text":"<p>Initialize Q-GMRES solver.</p>"},{"location":"api/solver/#quatica.solver.QGMRESSolver.__init__--parameters","title":"Parameters:","text":"<p>tol : float, optional     Tolerance for convergence (default: 1e-6) max_iter : int, optional     Maximum number of iterations (default: None, uses matrix dimension) verbose : bool, optional     Whether to print convergence information (default: False)</p>"},{"location":"api/solver/#quatica.solver.QGMRESSolver.solve","title":"<code>solve(A, b)</code>","text":"<p>Solve the quaternion linear system A * x = b using Q-GMRES.</p>"},{"location":"api/solver/#quatica.solver.QGMRESSolver.solve--parameters","title":"Parameters:","text":"<p>A : np.ndarray     Quaternion matrix (m x n) b : np.ndarray     Quaternion right-hand side vector (m x 1)</p>"},{"location":"api/solver/#quatica.solver.QGMRESSolver.solve--returns","title":"Returns:","text":"<p>x : np.ndarray     Solution vector (n x 1) info : dict     Information about the solution process including:     - 'iterations': Number of iterations performed     - 'residual': Final residual norm     - 'residual_history': List of residual norms     - 'converged': Whether the method converged</p>"},{"location":"api/solver/#quatica.solver.RandomizedSketchProjectPseudoinverse","title":"<code>RandomizedSketchProjectPseudoinverse</code>","text":"<p>Randomized Sketch-and-Project (RSP-Q) for quaternion matrix pseudoinverse.</p> <p>Implements the randomized sketch-and-project method for computing the Moore-Penrose pseudoinverse of quaternion matrices. This method provides global linear convergence in expectation through cheap randomized projections onto sketched identity constraints.</p> <p>The method works by drawing random sketches and projecting onto the constraint set {X: XY_k = Omega_k} where Y_k = AOmega_k and Omega_k is a random sketch. This provides a block Kaczmarz-style approach that converges globally.</p>"},{"location":"api/solver/#quatica.solver.RandomizedSketchProjectPseudoinverse.__init__","title":"<code>__init__(block_size=16, max_iter=1000, tol=1e-06, test_sketch_size=8, verbose=False, seed=None, column_solver='qr')</code>","text":"<p>Initialize the RSP-Q solver.</p>"},{"location":"api/solver/#quatica.solver.RandomizedSketchProjectPseudoinverse.__init__--parameters","title":"Parameters:","text":"<p>block_size : int, optional     Size of the random sketch block r (default: 16) max_iter : int, optional     Maximum number of iterations (default: 1000) tol : float, optional     Convergence tolerance (default: 1e-6) test_sketch_size : int, optional     Size of the test sketch for convergence check (default: 8) verbose : bool, optional     Whether to print convergence information (default: False) seed : int, optional     Random seed for reproducibility (default: None)</p>"},{"location":"api/solver/#quatica.solver.RandomizedSketchProjectPseudoinverse.compute","title":"<code>compute(A)</code>","text":"<p>Compute the Moore-Penrose pseudoinverse using RSP-Q.</p> <p>Automatically selects column or row variant based on matrix dimensions. This is the main entry point for RSP-Q pseudoinverse computation.</p>"},{"location":"api/solver/#quatica.solver.RandomizedSketchProjectPseudoinverse.compute--parameters","title":"Parameters:","text":"<p>A : np.ndarray     Quaternion matrix of shape (m, n)</p>"},{"location":"api/solver/#quatica.solver.RandomizedSketchProjectPseudoinverse.compute--returns","title":"Returns:","text":"<p>tuple[np.ndarray, dict]     X : np.ndarray         Moore-Penrose pseudoinverse of A, shape (n, m)     convergence_info : dict         Dictionary containing convergence information from the selected variant</p>"},{"location":"api/solver/#quatica.solver.RandomizedSketchProjectPseudoinverse.compute--notes","title":"Notes:","text":"<ul> <li>For m &gt;= n (tall/square matrices): uses column variant (compute_column_variant)</li> <li>For m &lt; n (wide matrices): uses row variant (compute_row_variant)</li> <li>Automatically clamps block_size to safe range [1, min(m, n)]</li> <li>Both variants provide global linear convergence in expectation</li> <li>The choice between variants is optimal for computational efficiency</li> </ul>"},{"location":"api/solver/#quatica.solver.RandomizedSketchProjectPseudoinverse.compute_column_variant","title":"<code>compute_column_variant(A)</code>","text":"<p>Compute pseudoinverse using column variant RSP-Q for full column rank A.</p> <p>Solves XA = I_n by iterative sketch-and-project updates. This variant is designed for tall matrices (m &gt;= n) and uses randomized sketching to reduce computational complexity.</p>"},{"location":"api/solver/#quatica.solver.RandomizedSketchProjectPseudoinverse.compute_column_variant--parameters","title":"Parameters:","text":"<p>A : np.ndarray     Full column rank quaternion matrix of shape (m, n) with m &gt;= n</p>"},{"location":"api/solver/#quatica.solver.RandomizedSketchProjectPseudoinverse.compute_column_variant--returns","title":"Returns:","text":"<p>tuple[np.ndarray, dict]     X : np.ndarray         Pseudoinverse of A, shape (n, m)     convergence_info : dict         Dictionary containing convergence information:         - 'iterations': Number of iterations performed         - 'residual_norms': List of residual norms per iteration         - 'iteration_times': List of CPU times per iteration         - 'total_time': Total computation time         - 'converged': Boolean indicating if convergence was achieved</p>"},{"location":"api/solver/#quatica.solver.RandomizedSketchProjectPseudoinverse.compute_column_variant--notes","title":"Notes:","text":"<ul> <li>Initializes with X_0 = (1/||A||_F^2) * A^H</li> <li>Uses random sketches of size block_size for each iteration</li> <li>Supports both QR and SPD update strategies via column_solver parameter</li> <li>Monitors convergence using a test sketch to avoid computing full residuals</li> <li>Global linear convergence in expectation for well-conditioned matrices</li> </ul>"},{"location":"api/solver/#quatica.solver.RandomizedSketchProjectPseudoinverse.compute_row_variant","title":"<code>compute_row_variant(A)</code>","text":"<p>RSP-Q row variant: solve A X = I_m for full row rank A (m &lt;= n).</p> <p>This variant is designed for wide matrices (m &lt;= n) and uses left sketching to project onto sketched identity constraints. The update formula is: X &lt;- X + Z^H (Z Z<sup>H)</sup>{-1} (S^H - Z X), where Z = S^H A.</p>"},{"location":"api/solver/#quatica.solver.RandomizedSketchProjectPseudoinverse.compute_row_variant--parameters","title":"Parameters:","text":"<p>A : np.ndarray     Full row rank quaternion matrix of shape (m, n) with m &lt;= n</p>"},{"location":"api/solver/#quatica.solver.RandomizedSketchProjectPseudoinverse.compute_row_variant--returns","title":"Returns:","text":"<p>tuple[np.ndarray, dict]     X : np.ndarray         Pseudoinverse of A, shape (n, m)     info : dict         Dictionary containing convergence information:         - 'iterations': Number of iterations performed         - 'residual_norms': List of residual norms per iteration         - 'iteration_times': List of CPU times per iteration         - 'total_time': Total computation time         - 'converged': Boolean indicating if convergence was achieved</p>"},{"location":"api/solver/#quatica.solver.RandomizedSketchProjectPseudoinverse.compute_row_variant--notes","title":"Notes:","text":"<ul> <li>Initializes with X_0 = 0 (zero initialization is sufficient for RSP)</li> <li>Uses left sketches S of size block_size for each iteration</li> <li>Solves (Z Z^H) W = R using CG micro-solver with fallback to Newton-Schulz</li> <li>Monitors convergence using proxy residual with test sketch</li> <li>Applies tiny ridge regularization (1e-10) to Gram matrix for stability</li> <li>Global linear convergence in expectation for well-conditioned matrices</li> </ul>"},{"location":"api/tensor/","title":"quatica.tensor","text":""},{"location":"api/tensor/#quatica.tensor","title":"<code>quatica.tensor</code>","text":""},{"location":"api/tensor/#quatica.tensor.tensor_entrywise_abs","title":"<code>tensor_entrywise_abs(T)</code>","text":"<p>Return entrywise quaternion magnitudes |T| for a quaternion tensor.</p> <p>Computes the modulus |q| = sqrt(w\u00b2 + x\u00b2 + y\u00b2 + z\u00b2) for each quaternion entry in the tensor, returning a real-valued tensor.</p>"},{"location":"api/tensor/#quatica.tensor.tensor_entrywise_abs--parameters","title":"Parameters:","text":"<p>T : np.ndarray     Quaternion tensor of arbitrary shape</p>"},{"location":"api/tensor/#quatica.tensor.tensor_entrywise_abs--returns","title":"Returns:","text":"<p>np.ndarray     Real tensor with same shape as T containing element-wise magnitudes</p>"},{"location":"api/tensor/#quatica.tensor.tensor_entrywise_abs--notes","title":"Notes:","text":"<p>The output is a real ndarray with the same shape as the input tensor, where each entry contains the magnitude of the corresponding quaternion.</p>"},{"location":"api/tensor/#quatica.tensor.tensor_fold","title":"<code>tensor_fold(M, mode, shape)</code>","text":"<p>Inverse of mode-n unfolding for an order-3 quaternion tensor.</p> <p>Converts an unfolded matrix back into its original tensor form by reversing the matricization operation. This is the inverse of tensor_unfold.</p>"},{"location":"api/tensor/#quatica.tensor.tensor_fold--parameters","title":"Parameters:","text":"<p>M : np.ndarray     Unfolded quaternion matrix mode : int     Folding mode (0, 1, or 2) corresponding to the original unfolding mode shape : tuple of int     Target tensor shape (I, J, K)</p>"},{"location":"api/tensor/#quatica.tensor.tensor_fold--returns","title":"Returns:","text":"<p>np.ndarray     Folded quaternion tensor of shape <code>shape</code></p>"},{"location":"api/tensor/#quatica.tensor.tensor_fold--raises","title":"Raises:","text":"<p>ValueError     If the matrix shape is incompatible with the folding mode and target shape</p>"},{"location":"api/tensor/#quatica.tensor.tensor_fold--notes","title":"Notes:","text":"<p>The mode must match the mode used in the original tensor_unfold operation for the folding to correctly reconstruct the tensor structure.</p>"},{"location":"api/tensor/#quatica.tensor.tensor_frobenius_norm","title":"<code>tensor_frobenius_norm(T)</code>","text":"<p>Frobenius-like norm of a quaternion tensor of arbitrary order.</p> <p>Computes ||T||_F = sqrt(sum of squares) over all four quaternion components (w, x, y, z) across all tensor entries.</p>"},{"location":"api/tensor/#quatica.tensor.tensor_frobenius_norm--parameters","title":"Parameters:","text":"<p>T : np.ndarray     Quaternion tensor of arbitrary shape</p>"},{"location":"api/tensor/#quatica.tensor.tensor_frobenius_norm--returns","title":"Returns:","text":"<p>float     Frobenius norm of the tensor</p>"},{"location":"api/tensor/#quatica.tensor.tensor_frobenius_norm--notes","title":"Notes:","text":"<p>This extends the matrix Frobenius norm to quaternion tensors by treating each quaternion entry as a 4-component vector and summing all squared components across the entire tensor.</p>"},{"location":"api/tensor/#quatica.tensor.tensor_unfold","title":"<code>tensor_unfold(T, mode)</code>","text":"<p>Mode-n unfolding (matricization) for an order-3 quaternion tensor.</p> <p>Converts a 3rd-order tensor into a matrix by arranging fibers along a specified mode. This is a fundamental operation in tensor decompositions.</p>"},{"location":"api/tensor/#quatica.tensor.tensor_unfold--parameters","title":"Parameters:","text":"<p>T : np.ndarray     Quaternion tensor of shape (I, J, K) mode : int     Unfolding mode (0, 1, or 2)</p>"},{"location":"api/tensor/#quatica.tensor.tensor_unfold--returns","title":"Returns:","text":"<p>np.ndarray     Unfolded matrix of shape (dims[mode], prod(other dims))</p>"},{"location":"api/tensor/#quatica.tensor.tensor_unfold--raises","title":"Raises:","text":"<p>ValueError     If T is not an order-3 quaternion tensor or mode is invalid</p>"},{"location":"api/tensor/#quatica.tensor.tensor_unfold--notes","title":"Notes:","text":"<ul> <li>Mode 0: unfolding along first dimension \u2192 shape (I, J*K)</li> <li>Mode 1: unfolding along second dimension \u2192 shape (J, I*K)</li> <li>Mode 2: unfolding along third dimension \u2192 shape (K, I*J)</li> </ul>"},{"location":"api/utils/","title":"quatica.utils","text":""},{"location":"api/utils/#quatica.utils","title":"<code>quatica.utils</code>","text":""},{"location":"api/utils/#quatica.utils.A2A0123","title":"<code>A2A0123(A)</code>","text":"<p>Extract component matrices from real matrix A = [A0 A2 A1 A3].</p>"},{"location":"api/utils/#quatica.utils.A2A0123--parameters","title":"Parameters:","text":"<p>A : numpy.ndarray     Real matrix with columns arranged as [A0 A2 A1 A3]     where each component matrix has n columns</p>"},{"location":"api/utils/#quatica.utils.A2A0123--returns","title":"Returns:","text":"<p>tuple : (A0, A1, A2, A3) component matrices</p>"},{"location":"api/utils/#quatica.utils.A2A0123--notes","title":"Notes:","text":"<p>Based on MATLAB implementation by Zhigang Jia (Aug 14, 2014)</p>"},{"location":"api/utils/#quatica.utils.GRSGivens","title":"<code>GRSGivens(g1, g2=None, g3=None, g4=None)</code>","text":"<p>Generate quaternion Givens rotation matrix for the last column.</p>"},{"location":"api/utils/#quatica.utils.GRSGivens--parameters","title":"Parameters:","text":"<p>g1 : float or numpy.ndarray     First quaternion component or 4-vector g2, g3, g4 : float, optional     Additional quaternion components (only used if g1 is scalar)</p>"},{"location":"api/utils/#quatica.utils.GRSGivens--returns","title":"Returns:","text":"<p>numpy.ndarray : 4x4 real Givens rotation matrix</p>"},{"location":"api/utils/#quatica.utils.GRSGivens--notes","title":"Notes:","text":"<p>Based on MATLAB implementation by Zhigang Jia</p>"},{"location":"api/utils/#quatica.utils.Hess_QR_ggivens","title":"<code>Hess_QR_ggivens(Hess)</code>","text":"<p>QR decomposition of quaternion Hessenberg matrix using Givens rotations.</p>"},{"location":"api/utils/#quatica.utils.Hess_QR_ggivens--parameters","title":"Parameters:","text":"<p>Hess : numpy.ndarray     Real block matrix representation of quaternion Hessenberg matrix     Hess = [A0; A1; A2; A3] where A0, A1, A2, A3 are the quaternion components</p>"},{"location":"api/utils/#quatica.utils.Hess_QR_ggivens--returns","title":"Returns:","text":"<p>tuple : (W, Hess) where W*Hess gives the QR factorization</p>"},{"location":"api/utils/#quatica.utils.Hess_QR_ggivens--notes","title":"Notes:","text":"<p>Based on MATLAB implementation by Zhigang Jia (Apr 21, 2020)</p>"},{"location":"api/utils/#quatica.utils.Realp","title":"<code>Realp(A1, A2, A3, A4)</code>","text":"<p>Convert quaternion matrix components to real block matrix representation.</p>"},{"location":"api/utils/#quatica.utils.Realp--parameters","title":"Parameters:","text":"<p>A1, A2, A3, A4 : numpy.ndarray or scalar     Quaternion matrix components (can be scalars or matrices)</p>"},{"location":"api/utils/#quatica.utils.Realp--returns","title":"Returns:","text":"<p>numpy.ndarray : Real block matrix AR = [A1 -A2 -A3 -A4; A2 A1 -A4 A3; A3 A4 A1 -A2; A4 -A3 A2 A1]</p>"},{"location":"api/utils/#quatica.utils.Realp--notes","title":"Notes:","text":"<p>Based on MATLAB implementation by Zhigang Jia</p>"},{"location":"api/utils/#quatica.utils.UtriangleQsparse","title":"<code>UtriangleQsparse(R0, R1, R2, R3, b0, b1, b2, b3, tol=1e-14)</code>","text":"<p>Solve quaternion upper triangular system R * x = b using backward substitution.</p>"},{"location":"api/utils/#quatica.utils.UtriangleQsparse--parameters","title":"Parameters:","text":"<p>R0, R1, R2, R3 : numpy.ndarray     Upper triangular matrix components b0, b1, b2, b3 : numpy.ndarray     Right-hand side vector components tol : float, optional     Tolerance for checking zero elements (default: 1e-14)</p>"},{"location":"api/utils/#quatica.utils.UtriangleQsparse--returns","title":"Returns:","text":"<p>tuple : (b0, b1, b2, b3) - Solution vector components (overwrites input b)</p>"},{"location":"api/utils/#quatica.utils.UtriangleQsparse--notes","title":"Notes:","text":"<p>Based on MATLAB implementation by Zhigang Jia &amp; Xuan Liu (Apr 22, 2020) Implements backward substitution: Algorithm 3.1.2, page 89, Matrix Computations, Golub and Van Loan, 3rd ed.</p>"},{"location":"api/utils/#quatica.utils.absQsparse","title":"<code>absQsparse(A0, A1, A2, A3)</code>","text":"<p>Compute absolute value/norm of quaternion in component format.</p>"},{"location":"api/utils/#quatica.utils.absQsparse--parameters","title":"Parameters:","text":"<p>A0, A1, A2, A3 : float or numpy.ndarray     Quaternion components</p>"},{"location":"api/utils/#quatica.utils.absQsparse--returns","title":"Returns:","text":"<p>tuple : (r, s0, s1, s2, s3) where r is the norm and s0,s1,s2,s3 are normalized components</p>"},{"location":"api/utils/#quatica.utils.absQsparse--notes","title":"Notes:","text":"<p>Based on MATLAB implementation by Zhigang Jia</p>"},{"location":"api/utils/#quatica.utils.compute_real_svd_pinv","title":"<code>compute_real_svd_pinv(X_real)</code>","text":"<p>Compute pseudoinverse using SVD in the real domain</p>"},{"location":"api/utils/#quatica.utils.det","title":"<code>det(X, d)</code>","text":"<p>Compute determinant of a quaternion matrix.</p>"},{"location":"api/utils/#quatica.utils.det--parameters","title":"Parameters:","text":"<p>X : numpy.ndarray with dtype=quaternion     Square quaternion matrix d : str     Determinant type:     - 'Moore': Product of eigenvalues (requires Hermitian matrix)     - 'Dieudonn\u00e9' or 'Dieudonne': Product of singular values     - 'Study': Determinant of the adjoint matrix</p>"},{"location":"api/utils/#quatica.utils.det--returns","title":"Returns:","text":"<p>complex or float : The computed determinant</p>"},{"location":"api/utils/#quatica.utils.det--notes","title":"Notes:","text":"<ul> <li>Moore determinant can be negative or complex, but requires Hermitian matrix</li> <li>Dieudonn\u00e9 determinant is always real</li> <li>Study determinant is the square of Dieudonn\u00e9 determinant</li> </ul>"},{"location":"api/utils/#quatica.utils.dotinvQsparse","title":"<code>dotinvQsparse(A0, A1, A2, A3)</code>","text":"<p>Compute quaternion inverse in component format.</p>"},{"location":"api/utils/#quatica.utils.dotinvQsparse--parameters","title":"Parameters:","text":"<p>A0, A1, A2, A3 : float or numpy.ndarray     Quaternion components</p>"},{"location":"api/utils/#quatica.utils.dotinvQsparse--returns","title":"Returns:","text":"<p>tuple : (inv0, inv1, inv2, inv3) - Inverse quaternion components</p>"},{"location":"api/utils/#quatica.utils.dotinvQsparse--notes","title":"Notes:","text":"<p>Based on MATLAB implementation by Zhigang Jia</p>"},{"location":"api/utils/#quatica.utils.ggivens","title":"<code>ggivens(x1, x2)</code>","text":"<p>Generate quaternion Givens rotation matrix.</p>"},{"location":"api/utils/#quatica.utils.ggivens--parameters","title":"Parameters:","text":"<p>x1, x2 : numpy.ndarray     Quaternion vectors (4-component arrays)</p>"},{"location":"api/utils/#quatica.utils.ggivens--returns","title":"Returns:","text":"<p>numpy.ndarray : 8x8 real Givens rotation matrix G such that G'*[x1;x2] = [||x||_2; 0]</p>"},{"location":"api/utils/#quatica.utils.ggivens--notes","title":"Notes:","text":"<p>Based on MATLAB implementation by Zhigang Jia, Musheng Wei, Meixiang Zhao and Yong Chen (Mar 24, 2017)</p>"},{"location":"api/utils/#quatica.utils.induced_matrix_norm_1","title":"<code>induced_matrix_norm_1(A)</code>","text":"<p>Matrix 1-norm induced by vector 1-norm: max column sum of |A_ij|.</p> Notes <ul> <li>Supports dense quaternion ndarrays. For sparse, convert to dense first or   use component-space helpers.</li> </ul>"},{"location":"api/utils/#quatica.utils.induced_matrix_norm_inf","title":"<code>induced_matrix_norm_inf(A)</code>","text":"<p>Matrix infinity-norm induced by vector infinity-norm: max row sum of |A_ij|.</p> Notes <ul> <li>Supports dense quaternion ndarrays. For sparse, convert to dense first or   use component-space helpers.</li> </ul>"},{"location":"api/utils/#quatica.utils.ishermitian","title":"<code>ishermitian(A, tol=None)</code>","text":"<p>Check if a quaternion matrix is Hermitian to within the given tolerance.</p>"},{"location":"api/utils/#quatica.utils.ishermitian--parameters","title":"Parameters:","text":"<p>A : numpy.ndarray with dtype=quaternion     Quaternion matrix to test tol : float, optional     Tolerance for comparison (default: machine epsilon)</p>"},{"location":"api/utils/#quatica.utils.ishermitian--returns","title":"Returns:","text":"<p>bool : True if matrix is Hermitian within tolerance</p>"},{"location":"api/utils/#quatica.utils.ishermitian--notes","title":"Notes:","text":"<p>A matrix A is Hermitian if A = A^H where A^H is the conjugate transpose.</p>"},{"location":"api/utils/#quatica.utils.matrix_norm","title":"<code>matrix_norm(A, ord=None)</code>","text":"<p>Compute common matrix norms for quaternion matrices.</p> ord supported <ul> <li>None or 'fro' or 'F': Frobenius norm</li> <li>1: Induced 1-norm (max column sum)</li> <li>np.inf or 'inf': Induced infinity-norm (max row sum)</li> <li>2: Spectral norm (largest singular value)</li> </ul>"},{"location":"api/utils/#quatica.utils.normQ","title":"<code>normQ(A, opt=None)</code>","text":"<p>Compute norm of quaternion matrix A.</p>"},{"location":"api/utils/#quatica.utils.normQ--parameters","title":"Parameters:","text":"<p>A : numpy.ndarray with dtype=quaternion     Quaternion matrix opt : str, optional     Norm type: 'd' (dual) or None (Frobenius)</p>"},{"location":"api/utils/#quatica.utils.normQ--returns","title":"Returns:","text":"<p>float : The computed norm</p>"},{"location":"api/utils/#quatica.utils.normQ--notes","title":"Notes:","text":"<p>Based on MATLAB implementation by Zhigang Jia (Jan 24, 2018)</p>"},{"location":"api/utils/#quatica.utils.normQsparse","title":"<code>normQsparse(A0, A1, A2, A3, opt=None)</code>","text":"<p>Compute norm of quaternion matrix in component format (A0, A1, A2, A3).</p>"},{"location":"api/utils/#quatica.utils.normQsparse--parameters","title":"Parameters:","text":"<p>A0, A1, A2, A3 : numpy.ndarray or scipy.sparse matrix     Quaternion matrix components opt : str, optional     Norm type: 'd' (dual), '2' (2-norm), '1' (1-norm), or None (Frobenius)</p>"},{"location":"api/utils/#quatica.utils.normQsparse--returns","title":"Returns:","text":"<p>float : The computed norm</p>"},{"location":"api/utils/#quatica.utils.normQsparse--notes","title":"Notes:","text":"<p>Based on MATLAB implementation by Zhigang Jia (Apr 27, 2020)</p>"},{"location":"api/utils/#quatica.utils.power_iteration","title":"<code>power_iteration(A, max_iterations=100, tol=1e-10, return_eigenvalue=False, verbose=False)</code>","text":"<p>Compute the dominant eigenvector of a quaternion matrix using power iteration.</p>"},{"location":"api/utils/#quatica.utils.power_iteration--parameters","title":"Parameters:","text":"<p>A : numpy.ndarray with dtype=quaternion     Square quaternion matrix of size n\u00d7n max_iterations : int, optional     Maximum number of iterations (default: 100) tol : float, optional     Convergence tolerance for vector norm difference (default: 1e-10) return_eigenvalue : bool, optional     If True, also return an eigenvalue estimate (default: False) verbose : bool, optional     If True, print convergence information and non-Hermitian warning (default: False)</p>"},{"location":"api/utils/#quatica.utils.power_iteration--returns","title":"Returns:","text":"<p>numpy.ndarray or tuple:     - If return_eigenvalue=False: dominant eigenvector (n\u00d71 quaternion vector)     - If return_eigenvalue=True: (eigenvector, eigenvalue_estimate) tuple</p>"},{"location":"api/utils/#quatica.utils.power_iteration--notes","title":"Notes:","text":"<ul> <li>Intended primarily for HERMITIAN quaternion matrices, where eigenvalues are real.   In that case this routine returns a meaningful dominant eigenpair.</li> <li>For general (non-Hermitian) quaternion matrices, the returned scalar when   return_eigenvalue=True is a magnitude-based Rayleigh-quotient estimate (real),   which can be interpreted as a real-part/magnitude heuristic, not a true complex   eigenvalue. For non-Hermitian matrices, use <code>power_iteration_nonhermitian</code> which   returns complex eigenvalues (in a fixed complex subfield) and quaternion eigenvectors.</li> </ul> <p>Algorithm: 1) Start with a random vector 2) Iterate v_{k+1} = A v_k / ||A v_k|| 3) Stop when ||v_{k+1} - v_k|| &lt; tol or max_iterations reached</p>"},{"location":"api/utils/#quatica.utils.power_iteration_nonhermitian","title":"<code>power_iteration_nonhermitian(A, max_iterations=5000, eig_tol=1e-12, res_tol=1e-10, seed=0, return_vector=True, eigenvalue_format='complex', subfield_axis='x', block_purify=True)</code>","text":"<p>Power iteration for NON-Hermitian quaternion matrices (experimental).</p> <p>Returns a complex eigenvalue estimate (in a chosen complex subfield) and a corresponding quaternion eigenvector approximation.</p>"},{"location":"api/utils/#quatica.utils.power_iteration_nonhermitian--parameters","title":"Parameters","text":"<p>A : np.ndarray     Square quaternion matrix (non-Hermitian allowed) max_iterations : int     Maximum iterations for the complex power iteration eig_tol : float     Tolerance for eigenvalue stabilization res_tol : float | None     Residual tolerance on ||Mv - lambda v|| to declare convergence seed : int     RNG seed for initialization return_vector : bool     If True, also return the quaternion eigenvector approximation eigenvalue_format : {\"complex\", \"quaternion\"}     Output format for the eigenvalue. Default is \"complex\". subfield_axis : {\"x\"}     Imaginary axis defining complex subfield for the adjoint (currently only \"x\").</p>"},{"location":"api/utils/#quatica.utils.power_iteration_nonhermitian--notes","title":"Notes","text":"<ul> <li>For Hermitian matrices, prefer <code>power_iteration</code>, which returns a quaternion   eigenvector and a real-valued eigenvalue magnitude.</li> <li>Eigenvalues appear in conjugate pairs in the adjoint; this returns one complex root.</li> </ul>"},{"location":"api/utils/#quatica.utils.quat_abs_scalar","title":"<code>quat_abs_scalar(q)</code>","text":"<p>Return the modulus |q| of a quaternion scalar q.</p> <p>Computes the absolute value (modulus) of a quaternion q = w + xi + yj + zk as |q| = sqrt(w\u00b2 + x\u00b2 + y\u00b2 + z\u00b2).</p>"},{"location":"api/utils/#quatica.utils.quat_abs_scalar--parameters","title":"Parameters:","text":"<p>q : quaternion.quaternion     Input quaternion scalar</p>"},{"location":"api/utils/#quatica.utils.quat_abs_scalar--returns","title":"Returns:","text":"<p>float     Modulus (absolute value) of the quaternion</p>"},{"location":"api/utils/#quatica.utils.quat_abs_scalar--notes","title":"Notes:","text":"<p>The quaternion modulus satisfies |q\u2081 * q\u2082| = |q\u2081| * |q\u2082| and is used in defining norms and distances in quaternion space.</p>"},{"location":"api/utils/#quatica.utils.quat_eye","title":"<code>quat_eye(n)</code>","text":"<p>Create an n\u00d7n identity quaternion matrix.</p> <p>Generates the quaternion identity matrix I where I_ij = \u03b4_ij * (1 + 0i + 0j + 0k), i.e., ones on the diagonal and zeros elsewhere.</p>"},{"location":"api/utils/#quatica.utils.quat_eye--parameters","title":"Parameters:","text":"<p>n : int     Size of the square identity matrix</p>"},{"location":"api/utils/#quatica.utils.quat_eye--returns","title":"Returns:","text":"<p>np.ndarray     An n\u00d7n quaternion identity matrix</p>"},{"location":"api/utils/#quatica.utils.quat_eye--notes","title":"Notes:","text":"<p>The quaternion identity matrix satisfies A @ I = I @ A = A for any n\u00d7n quaternion matrix A.</p>"},{"location":"api/utils/#quatica.utils.quat_frobenius_norm","title":"<code>quat_frobenius_norm(A)</code>","text":"<p>Compute the Frobenius norm of a quaternion matrix (dense or sparse).</p> <p>Calculates ||A||_F = sqrt(sum(|A_ij|^2)) where |A_ij| is the modulus of the quaternion at position (i,j).</p>"},{"location":"api/utils/#quatica.utils.quat_frobenius_norm--parameters","title":"Parameters:","text":"<p>A : np.ndarray or SparseQuaternionMatrix     Input quaternion matrix</p>"},{"location":"api/utils/#quatica.utils.quat_frobenius_norm--returns","title":"Returns:","text":"<p>float     Frobenius norm of the matrix</p>"},{"location":"api/utils/#quatica.utils.quat_frobenius_norm--notes","title":"Notes:","text":"<p>For sparse matrices, the norm is computed efficiently by summing the squared norms of each component separately.</p>"},{"location":"api/utils/#quatica.utils.quat_hermitian","title":"<code>quat_hermitian(A)</code>","text":"<p>Return the conjugate transpose (Hermitian) of quaternion matrix A (dense or sparse).</p> <p>Computes A^H = (A)^T where A is the complex conjugate and T is transpose. For quaternions q = w + xi + yj + zk, the conjugate is q* = w - xi - yj - zk.</p>"},{"location":"api/utils/#quatica.utils.quat_hermitian--parameters","title":"Parameters:","text":"<p>A : np.ndarray or SparseQuaternionMatrix     Input quaternion matrix</p>"},{"location":"api/utils/#quatica.utils.quat_hermitian--returns","title":"Returns:","text":"<p>np.ndarray or SparseQuaternionMatrix     Conjugate transpose A^H of the input matrix</p>"},{"location":"api/utils/#quatica.utils.quat_hermitian--notes","title":"Notes:","text":"<p>The Hermitian (conjugate transpose) is fundamental in quaternion linear algebra and appears in definitions of unitary matrices, eigenvalue problems, and norms.</p>"},{"location":"api/utils/#quatica.utils.quat_kernel","title":"<code>quat_kernel(A, side='right', rtol=1e-10)</code>","text":"<p>Compute the kernel (null space) of a quaternion matrix.</p> <p>Alias for quat_null_space() with identical functionality.</p>"},{"location":"api/utils/#quatica.utils.quat_kernel--parameters","title":"Parameters:","text":"<p>A : numpy.ndarray with dtype=quaternion     Input quaternion matrix of shape (m, n) side : str, optional     'right' for ker(A), 'left' for ker(A^H)     Default: 'right' rtol : float, optional     Relative tolerance for determining rank     Default: 1e-10</p>"},{"location":"api/utils/#quatica.utils.quat_kernel--returns","title":"Returns:","text":"<p>N : numpy.ndarray with dtype=quaternion     Kernel matrix such that A @ N \u2248 0 (right) or N^H @ A \u2248 0 (left)</p>"},{"location":"api/utils/#quatica.utils.quat_matmat","title":"<code>quat_matmat(A, B)</code>","text":"<p>Multiply two quaternion matrices (supports dense \u00d7 dense, sparse \u00d7 dense, dense \u00d7 sparse, sparse \u00d7 sparse).</p> <p>Performs quaternion matrix multiplication using optimized algorithms based on the input types. Handles mixed sparse/dense operations efficiently.</p>"},{"location":"api/utils/#quatica.utils.quat_matmat--parameters","title":"Parameters:","text":"<p>A : np.ndarray or SparseQuaternionMatrix     First quaternion matrix B : np.ndarray or SparseQuaternionMatrix     Second quaternion matrix</p>"},{"location":"api/utils/#quatica.utils.quat_matmat--returns","title":"Returns:","text":"<p>np.ndarray or SparseQuaternionMatrix     Result of quaternion matrix multiplication A @ B</p>"},{"location":"api/utils/#quatica.utils.quat_matmat--notes","title":"Notes:","text":"<p>The function automatically selects the appropriate multiplication algorithm: - Dense \u00d7 Dense: Component-wise quaternion multiplication - Sparse \u00d7 Dense/Sparse: Uses sparse matrix multiplication routines - Dense \u00d7 Sparse: Uses left multiplication method</p>"},{"location":"api/utils/#quatica.utils.quat_null_left","title":"<code>quat_null_left(A, rtol=1e-10)</code>","text":"<p>Compute the left null space of a quaternion matrix: null(A^H).</p>"},{"location":"api/utils/#quatica.utils.quat_null_left--parameters","title":"Parameters:","text":"<p>A : numpy.ndarray with dtype=quaternion     Input quaternion matrix of shape (m, n) rtol : float, optional     Relative tolerance for determining rank     Default: 1e-10</p>"},{"location":"api/utils/#quatica.utils.quat_null_left--returns","title":"Returns:","text":"<p>N : numpy.ndarray with dtype=quaternion     Left null space matrix of shape (m, m-rank) such that N^H @ A \u2248 0</p>"},{"location":"api/utils/#quatica.utils.quat_null_left--notes","title":"Notes:","text":"<p>Convenience function equivalent to quat_null_space(A, side='left', rtol=rtol)</p>"},{"location":"api/utils/#quatica.utils.quat_null_right","title":"<code>quat_null_right(A, rtol=1e-10)</code>","text":"<p>Compute the right null space of a quaternion matrix: null(A).</p>"},{"location":"api/utils/#quatica.utils.quat_null_right--parameters","title":"Parameters:","text":"<p>A : numpy.ndarray with dtype=quaternion     Input quaternion matrix of shape (m, n) rtol : float, optional     Relative tolerance for determining rank     Default: 1e-10</p>"},{"location":"api/utils/#quatica.utils.quat_null_right--returns","title":"Returns:","text":"<p>N : numpy.ndarray with dtype=quaternion     Right null space matrix of shape (n, n-rank) such that A @ N \u2248 0</p>"},{"location":"api/utils/#quatica.utils.quat_null_right--notes","title":"Notes:","text":"<p>Convenience function equivalent to quat_null_space(A, side='right', rtol=rtol)</p>"},{"location":"api/utils/#quatica.utils.quat_null_space","title":"<code>quat_null_space(A, side='right', rtol=1e-10)</code>","text":"<p>Compute the null space (kernel) of a quaternion matrix using Q-SVD.</p>"},{"location":"api/utils/#quatica.utils.quat_null_space--parameters","title":"Parameters:","text":"<p>A : numpy.ndarray with dtype=quaternion     Input quaternion matrix of shape (m, n) side : str, optional     'right' for right null space (null(A)), 'left' for left null space (null(A^H))     Default: 'right' rtol : float, optional     Relative tolerance for determining rank (singular values &lt;= rtol * max(s) are zero)     Default: 1e-10</p>"},{"location":"api/utils/#quatica.utils.quat_null_space--returns","title":"Returns:","text":"<p>N : numpy.ndarray with dtype=quaternion     For side='right': null space matrix of shape (n, n-rank) such that A @ N \u2248 0     For side='left': null space matrix of shape (m, m-rank) such that N^H @ A \u2248 0</p>"},{"location":"api/utils/#quatica.utils.quat_null_space--notes","title":"Notes:","text":"<p>Uses Q-SVD: A = U @ \u03a3 @ V^H - Right null space: columns of V corresponding to zero singular values - Left null space: columns of U corresponding to zero singular values</p>"},{"location":"api/utils/#quatica.utils.quat_null_space--examples","title":"Examples:","text":"<p>A = create_test_matrix(5, 3)  # 5x3 matrix, rank \u2264 3 N_right = quat_null_space(A, side='right')  # null(A) N_left = quat_null_space(A, side='left')    # null(A^H) print(f\"Right null space: {N_right.shape}\")  # (3, 3-rank) print(f\"Left null space: {N_left.shape}\")   # (5, 5-rank)</p>"},{"location":"api/utils/#quatica.utils.quaternion_to_complex_adjoint","title":"<code>quaternion_to_complex_adjoint(A, axis='x')</code>","text":"<p>Map quaternion matrix A to 2n\u00d72n complex adjoint matrix for a chosen complex subfield.</p> <p>By default the complex subfield is tied to the x-axis (unit i):   A = W + X i + Y j + Z k \u2192 C = W + i X, D = Y + i Z,  Adj(A) = [[C, D], [-D, C]]</p>"},{"location":"api/utils/#quatica.utils.quaternion_to_complex_adjoint--parameters","title":"Parameters","text":"<p>A : np.ndarray (n\u00d7n, dtype=np.quaternion) axis : {\"x\"}     Imaginary axis defining the complex subfield. Currently only \"x\" is supported.</p>"},{"location":"api/utils/#quatica.utils.quaternion_to_complex_adjoint--notes","title":"Notes","text":"<p>Extending to other axes requires a consistent symplectic embedding relative to that axis.</p>"},{"location":"api/utils/#quatica.utils.rank","title":"<code>rank(X, tol=None)</code>","text":"<p>Compute the rank of a quaternion matrix by counting non-zero singular values.</p>"},{"location":"api/utils/#quatica.utils.rank--parameters","title":"Parameters:","text":"<p>X : numpy.ndarray with dtype=quaternion     Quaternion matrix of any shape (m, n) tol : float, optional     Tolerance for considering singular values as non-zero     (default: machine epsilon * max(m,n) * max singular value)</p>"},{"location":"api/utils/#quatica.utils.rank--returns","title":"Returns:","text":"<p>int : The rank of the matrix (number of non-zero singular values)</p>"},{"location":"api/utils/#quatica.utils.rank--notes","title":"Notes:","text":"<p>The rank is computed by: 1. Computing the SVD of the matrix: X = U @ S @ V^H 2. Counting singular values above the tolerance threshold 3. The rank equals the number of non-zero singular values</p> <p>The tolerance is automatically adjusted based on matrix size and magnitude to handle numerical precision issues.</p>"},{"location":"api/utils/#quatica.utils.real_contract","title":"<code>real_contract(R, m, n)</code>","text":"<p>Convert real block matrix R back to quaternion matrix. Invert real_expand back into an m\u00d7n quaternion array</p>"},{"location":"api/utils/#quatica.utils.real_expand","title":"<code>real_expand(Q)</code>","text":"<p>Convert quaternion matrix Q to real block matrix representation. Given an m\u00d7n quaternion array Q, return a (4m)\u00d7(4n) real block matrix [[Qw, -Qx, -Qy, -Qz],  [Qx,  Qw, -Qz,  Qy],  [Qy,  Qz,  Qw, -Qx],  [Qz, -Qy,  Qx,  Qw]]</p>"},{"location":"api/utils/#quatica.utils.spectral_norm_2","title":"<code>spectral_norm_2(A)</code>","text":"<p>Matrix 2-norm (spectral norm): largest singular value of A.</p> <p>Delegates to quaternion SVD implementation.</p>"},{"location":"api/utils/#quatica.utils.timesQsparse","title":"<code>timesQsparse(B0, B1, B2, B3, C0, C1, C2, C3)</code>","text":"<p>Quaternion matrix multiplication in component format.</p>"},{"location":"api/utils/#quatica.utils.timesQsparse--parameters","title":"Parameters:","text":"<p>B0, B1, B2, B3 : numpy.ndarray or scipy.sparse matrix     First quaternion matrix components C0, C1, C2, C3 : numpy.ndarray or scipy.sparse matrix     Second quaternion matrix components</p>"},{"location":"api/utils/#quatica.utils.timesQsparse--returns","title":"Returns:","text":"<p>tuple : (A0, A1, A2, A3) - Result quaternion matrix components</p>"},{"location":"api/utils/#quatica.utils.timesQsparse--notes","title":"Notes:","text":"<p>Implements quaternion multiplication: A = B * C Based on MATLAB implementation by Zhigang Jia</p>"},{"location":"api/visualization/","title":"quatica.visualization","text":""},{"location":"api/visualization/#quatica.visualization","title":"<code>quatica.visualization</code>","text":""},{"location":"api/visualization/#quatica.visualization.Visualizer","title":"<code>Visualizer</code>","text":""},{"location":"api/visualization/#quatica.visualization.Visualizer.plot_convergence_comparison","title":"<code>plot_convergence_comparison(data_dict, title='Convergence Comparison', xlabel='Iteration', ylabel='Residual', logscale=True, save_path=None)</code>  <code>staticmethod</code>","text":"<p>Plot convergence comparison for multiple algorithms/variants.</p>"},{"location":"api/visualization/#quatica.visualization.Visualizer.plot_covariances","title":"<code>plot_covariances(covariances, title='Covariance Deviation', subtitle='')</code>  <code>staticmethod</code>","text":"<p>Plot covariance deviation ||AX - I|| or ||XA - I|| over iterations.</p> <p>Visualizes how well the computed pseudoinverse satisfies the covariance conditions during Newton-Schulz iterations.</p>"},{"location":"api/visualization/#quatica.visualization.Visualizer.plot_covariances--parameters","title":"Parameters:","text":"<p>covariances : list[float]     List of covariance deviation values over iterations title : str, optional     Main plot title (default: \"Covariance Deviation\") subtitle : str, optional     Additional subtitle text (default: \"\")</p>"},{"location":"api/visualization/#quatica.visualization.Visualizer.plot_covariances--notes","title":"Notes:","text":"<p>Uses logarithmic scale to track convergence. The covariance deviation measures how close XA (or AX) is to the identity matrix.</p>"},{"location":"api/visualization/#quatica.visualization.Visualizer.plot_residuals","title":"<code>plot_residuals(residuals, title='Residual Norms', subtitle='')</code>  <code>staticmethod</code>","text":"<p>Plot Moore-Penrose residual norms over iterations.</p> <p>Creates a logarithmic plot showing the convergence behavior of different residual types during pseudoinverse computation.</p>"},{"location":"api/visualization/#quatica.visualization.Visualizer.plot_residuals--parameters","title":"Parameters:","text":"<p>residuals : dict[str, list[float]]     Dictionary mapping residual names to their values over iterations title : str, optional     Main plot title (default: \"Residual Norms\") subtitle : str, optional     Additional subtitle text (default: \"\")</p>"},{"location":"api/visualization/#quatica.visualization.Visualizer.plot_residuals--notes","title":"Notes:","text":"<p>Uses semilogy scale to better visualize exponential convergence patterns typical in iterative pseudoinverse algorithms.</p>"},{"location":"api/visualization/#quatica.visualization.Visualizer.visualize_matrix","title":"<code>visualize_matrix(A, component=0, cmap='viridis', title='Matrix Component Heatmap', subtitle='')</code>  <code>staticmethod</code>","text":"<p>Heatmap of a chosen quaternion component (0=w, 1=x, 2=y, 3=z).</p> <p>Displays a specific quaternion component as a 2D heatmap to visualize the structure and patterns within the matrix.</p>"},{"location":"api/visualization/#quatica.visualization.Visualizer.visualize_matrix--parameters","title":"Parameters:","text":"<p>A : np.ndarray or SparseQuaternionMatrix     Input quaternion matrix component : int, optional     Quaternion component to visualize: 0=w, 1=x, 2=y, 3=z (default: 0) cmap : str, optional     Matplotlib colormap name (default: 'viridis') title : str, optional     Main plot title (default: \"Matrix Component Heatmap\") subtitle : str, optional     Additional subtitle text (default: \"\")</p>"},{"location":"api/visualization/#quatica.visualization.Visualizer.visualize_matrix--notes","title":"Notes:","text":"<p>Automatically handles both dense and sparse quaternion matrices by converting sparse matrices to dense format for visualization.</p>"},{"location":"api/visualization/#quatica.visualization.Visualizer.visualize_matrix_abs","title":"<code>visualize_matrix_abs(A, cmap='viridis', title='Matrix Absolute Value', subtitle='')</code>  <code>staticmethod</code>","text":"<p>Heatmap of quaternion matrix absolute values |q| = sqrt(w\u00b2 + x\u00b2 + y\u00b2 + z\u00b2).</p> <p>Displays the magnitude of each quaternion entry as a 2D heatmap, providing insight into the overall structure and numerical behavior.</p>"},{"location":"api/visualization/#quatica.visualization.Visualizer.visualize_matrix_abs--parameters","title":"Parameters:","text":"<p>A : np.ndarray or SparseQuaternionMatrix     Input quaternion matrix cmap : str, optional     Matplotlib colormap name (default: 'viridis') title : str, optional     Main plot title (default: \"Matrix Absolute Value\") subtitle : str, optional     Additional subtitle text (default: \"\")</p>"},{"location":"api/visualization/#quatica.visualization.Visualizer.visualize_matrix_abs--notes","title":"Notes:","text":"<p>The absolute value (magnitude) is computed as the quaternion norm, which is invariant under quaternion rotations and provides a scalar measure of quaternion \"size\".</p>"},{"location":"api/visualization/#quatica.visualization.Visualizer.visualize_schur_structure","title":"<code>visualize_schur_structure(T, title='Schur Form Structure', subtitle='', threshold=1e-12)</code>  <code>staticmethod</code>","text":"<p>Visualize the structure of a Schur form matrix T and compute structure metrics.</p> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (below_diagonal_max, subdiagonal_max) for quantitative analysis</p>"},{"location":"api/visualization/#quatica.visualization.Visualizer.visualize_tensor_slice","title":"<code>visualize_tensor_slice(T, mode=0, slice_idx=0, cmap='viridis', title='Tensor Slice', show_abs=True)</code>  <code>staticmethod</code>","text":"<p>Visualize a 2D slice of a quaternion tensor T(I\u00d7J\u00d7K).</p>"},{"location":"api/decomp/LU/","title":"quatica.decomp.LU","text":""},{"location":"api/decomp/LU/#quatica.decomp.LU","title":"<code>quatica.decomp.LU</code>","text":"<p>Quaternion LU Decomposition Module</p> <p>This module provides LU decomposition for quaternion matrices using Gaussian elimination with partial pivoting, following the MATLAB QTFM implementation.</p> <p>Algorithm: Gaussian elimination with partial pivoting - Partial pivoting based on modulus of quaternion elements - In-place computation (L and U stored in the same matrix) - Handles all cases: m &gt; n, m == n, m &lt; n - Supports both 2-output (L, U) and 3-output (L, U, P) modes</p> <p>References: - MATLAB QTFM (Quaternion Toolbox for MATLAB) implementation: http://qtfm.sourceforge.net/ by Stephen J. Sangwine &amp; Nicolas Le Bihan - Golub, G. H., &amp; Van Loan, C. F. (1996). Matrix Computations (3rd ed.) - Algorithm 3.2.1, section 3.2.6, modified along the lines of section 3.2.11</p>"},{"location":"api/decomp/LU/#quatica.decomp.LU.quaternion_lu","title":"<code>quaternion_lu(A, return_p=False)</code>","text":"<p>LU decomposition of quaternion matrix using Gaussian elimination with partial pivoting.</p>"},{"location":"api/decomp/LU/#quatica.decomp.LU.quaternion_lu--parameters","title":"Parameters:","text":"<p>A : numpy.ndarray with dtype=quaternion     Input quaternion matrix of shape (m, n) return_p : bool, optional     Whether to return permutation matrix P (default: False)</p>"},{"location":"api/decomp/LU/#quatica.decomp.LU.quaternion_lu--returns","title":"Returns:","text":"<p>tuple : (L, U) or (L, U, P)     L : m\u00d7N quaternion matrix (lower triangular with unit diagonal)     U : N\u00d7n quaternion matrix (upper triangular)     P : m\u00d7m permutation matrix (only if return_p=True)     where N = min(m, n)</p>"},{"location":"api/decomp/LU/#quatica.decomp.LU.quaternion_lu--notes","title":"Notes:","text":"<ul> <li>Uses partial pivoting based on modulus of quaternion elements</li> <li>Handles all matrix shapes: m &gt; n, m == n, m &lt; n</li> <li>If return_p=False, L is permuted so that A = L * U</li> <li>If return_p=True, P * A = L * U</li> </ul>"},{"location":"api/decomp/LU/#quatica.decomp.LU.quaternion_modulus","title":"<code>quaternion_modulus(A)</code>","text":"<p>Compute the modulus (magnitude) of quaternion matrix elements.</p>"},{"location":"api/decomp/LU/#quatica.decomp.LU.quaternion_modulus--parameters","title":"Parameters:","text":"<p>A : numpy.ndarray with dtype=quaternion     Input quaternion matrix</p>"},{"location":"api/decomp/LU/#quatica.decomp.LU.quaternion_modulus--returns","title":"Returns:","text":"<p>numpy.ndarray : Real array of moduli</p>"},{"location":"api/decomp/LU/#quatica.decomp.LU.quaternion_tril","title":"<code>quaternion_tril(A, k=0)</code>","text":"<p>Extract lower triangular part of quaternion matrix.</p>"},{"location":"api/decomp/LU/#quatica.decomp.LU.quaternion_tril--parameters","title":"Parameters:","text":"<p>A : numpy.ndarray with dtype=quaternion     Input quaternion matrix k : int, optional     Diagonal offset (default: 0)</p>"},{"location":"api/decomp/LU/#quatica.decomp.LU.quaternion_tril--returns","title":"Returns:","text":"<p>numpy.ndarray : Lower triangular quaternion matrix</p>"},{"location":"api/decomp/LU/#quatica.decomp.LU.quaternion_triu","title":"<code>quaternion_triu(A, k=0)</code>","text":"<p>Extract upper triangular part of quaternion matrix.</p>"},{"location":"api/decomp/LU/#quatica.decomp.LU.quaternion_triu--parameters","title":"Parameters:","text":"<p>A : numpy.ndarray with dtype=quaternion     Input quaternion matrix k : int, optional     Diagonal offset (default: 0)</p>"},{"location":"api/decomp/LU/#quatica.decomp.LU.quaternion_triu--returns","title":"Returns:","text":"<p>numpy.ndarray : Upper triangular quaternion matrix</p>"},{"location":"api/decomp/LU/#quatica.decomp.LU.verify_lu_decomposition","title":"<code>verify_lu_decomposition(A, L, U, P=None, verbose=False)</code>","text":"<p>Verify LU decomposition by checking reconstruction accuracy.</p>"},{"location":"api/decomp/LU/#quatica.decomp.LU.verify_lu_decomposition--parameters","title":"Parameters:","text":"<p>A : numpy.ndarray with dtype=quaternion     Original quaternion matrix L : numpy.ndarray with dtype=quaternion     Lower triangular matrix U : numpy.ndarray with dtype=quaternion     Upper triangular matrix P : numpy.ndarray with dtype=quaternion, optional     Permutation matrix verbose : bool, optional     Whether to print verification results</p>"},{"location":"api/decomp/LU/#quatica.decomp.LU.verify_lu_decomposition--returns","title":"Returns:","text":"<p>dict : Verification results</p>"},{"location":"api/decomp/eigen/","title":"quatica.decomp.eigen","text":""},{"location":"api/decomp/eigen/#quatica.decomp.eigen","title":"<code>quatica.decomp.eigen</code>","text":"<p>Quaternion Matrix Eigendecomposition Module</p> <p>This module provides eigenvalue decomposition algorithms for HERMITIAN quaternion matrices.</p> <p>\u26a0\ufe0f  IMPORTANT: This implementation is ONLY for Hermitian quaternion matrices.    For non-Hermitian matrices, consider using the adjoint matrix approach.</p> <p>Main functions: - quaternion_eigendecomposition: Eigendecomposition for Hermitian quaternion matrices - quaternion_eigenvalues: Extract eigenvalues only (Hermitian matrices only) - quaternion_eigenvectors: Extract eigenvectors only (Hermitian matrices only)</p> <p>Algorithm: Tridiagonalization + Standard Eigendecomposition - Tridiagonalize Hermitian matrix A: P * A * P^H = B - Compute eigendecomposition of tridiagonal matrix B using numpy.linalg.eig - Transform eigenvectors back: V = P^H * V_B</p> <p>Limitations: - Only works for Hermitian quaternion matrices - For non-Hermitian matrices, use adjoint matrix approach - For single quaternions, use adjoint matrix approach</p> <p>References: - MATLAB QTFM (Quaternion Toolbox for MATLAB) implementation: http://qtfm.sourceforge.net/ by Stephen J. Sangwine &amp; Nicolas Le Bihan</p>"},{"location":"api/decomp/eigen/#quatica.decomp.eigen.quaternion_eigendecomposition","title":"<code>quaternion_eigendecomposition(A_quat, verbose=False)</code>","text":"<p>Compute eigendecomposition of Hermitian quaternion matrix.</p>"},{"location":"api/decomp/eigen/#quatica.decomp.eigen.quaternion_eigendecomposition--parameters","title":"Parameters:","text":"<p>A_quat : numpy.ndarray with dtype=quaternion     Input quaternion matrix (must be square and Hermitian) verbose : bool     Whether to print convergence information</p>"},{"location":"api/decomp/eigen/#quatica.decomp.eigen.quaternion_eigendecomposition--returns","title":"Returns:","text":"<p>tuple : (eigenvalues, eigenvectors)     eigenvalues : complex array of eigenvalues     eigenvectors : quaternion matrix of eigenvectors</p>"},{"location":"api/decomp/eigen/#quatica.decomp.eigen.quaternion_eigenvalues","title":"<code>quaternion_eigenvalues(A_quat, verbose=False)</code>","text":"<p>Compute only eigenvalues of Hermitian quaternion matrix.</p>"},{"location":"api/decomp/eigen/#quatica.decomp.eigen.quaternion_eigenvalues--parameters","title":"Parameters:","text":"<p>A_quat : numpy.ndarray with dtype=quaternion     Input quaternion matrix (must be square and Hermitian) verbose : bool     Whether to print convergence information</p>"},{"location":"api/decomp/eigen/#quatica.decomp.eigen.quaternion_eigenvalues--returns","title":"Returns:","text":"<p>eigenvalues : complex array     Eigenvalues of the matrix</p>"},{"location":"api/decomp/eigen/#quatica.decomp.eigen.quaternion_eigenvectors","title":"<code>quaternion_eigenvectors(A_quat, verbose=False)</code>","text":"<p>Compute only eigenvectors of Hermitian quaternion matrix.</p>"},{"location":"api/decomp/eigen/#quatica.decomp.eigen.quaternion_eigenvectors--parameters","title":"Parameters:","text":"<p>A_quat : numpy.ndarray with dtype=quaternion     Input quaternion matrix (must be square and Hermitian) verbose : bool     Whether to print convergence information</p>"},{"location":"api/decomp/eigen/#quatica.decomp.eigen.quaternion_eigenvectors--returns","title":"Returns:","text":"<p>eigenvectors : quaternion matrix     Matrix of eigenvectors (columns are eigenvectors)</p>"},{"location":"api/decomp/eigen/#quatica.decomp.eigen.verify_eigendecomposition","title":"<code>verify_eigendecomposition(A_quat, eigenvalues, eigenvectors, verbose=False)</code>","text":"<p>Verify eigendecomposition by checking A * v = \u03bb * v for each eigenpair.</p>"},{"location":"api/decomp/eigen/#quatica.decomp.eigen.verify_eigendecomposition--parameters","title":"Parameters:","text":"<p>A_quat : quaternion matrix eigenvalues : complex array eigenvectors : quaternion matrix (columns are eigenvectors) verbose : bool</p>"},{"location":"api/decomp/eigen/#quatica.decomp.eigen.verify_eigendecomposition--returns","title":"Returns:","text":"<p>dict : verification results</p>"},{"location":"api/decomp/hessenberg/","title":"quatica.decomp.hessenberg","text":""},{"location":"api/decomp/hessenberg/#quatica.decomp.hessenberg","title":"<code>quatica.decomp.hessenberg</code>","text":"<p>Quaternion Matrix Hessenberg Reduction Module</p> <p>This module implements reduction of a general quaternion matrix to upper Hessenberg form using Householder similarity transformations.</p> <p>Key properties: - For a square matrix A, there exists a unitary P such that H = P * A * P^H   is upper Hessenberg (all entries strictly below the first subdiagonal are 0).</p> <p>Notes: - We reuse the quaternion Householder machinery already implemented for   Hermitian tridiagonalization. Here, we adapt it to the general (non-Hermitian)   Hessenberg case by zeroing elements below the first subdiagonal column-by-column.</p> <p>Constraints: - Per project rules, this module is added without modifying existing core   functions. It only depends on utilities and existing Householder helpers.</p>"},{"location":"api/decomp/hessenberg/#quatica.decomp.hessenberg.check_hessenberg","title":"<code>check_hessenberg(H, atol=1e-12)</code>","text":"<p>Clean tiny entries below first subdiagonal to exact zeros (for readability).</p> <p>Parameters: - H: quaternion matrix suspected to be upper Hessenberg - atol: tolerance below which entries are zeroed</p>"},{"location":"api/decomp/hessenberg/#quatica.decomp.hessenberg.hessenbergize","title":"<code>hessenbergize(A)</code>","text":"<p>Reduce a general square quaternion matrix A to upper Hessenberg form.</p> <p>Returns (P, H) such that H = P * A * P^H and H is upper Hessenberg.</p> <p>Parameters: - A: (n x n) quaternion numpy array</p> <p>Returns: - P: unitary quaternion matrix accumulating the similarity transforms - H: upper Hessenberg quaternion matrix</p>"},{"location":"api/decomp/hessenberg/#quatica.decomp.hessenberg.is_hessenberg","title":"<code>is_hessenberg(H, atol=1e-12)</code>","text":"<p>Return True if quaternion matrix H is upper Hessenberg within tolerance.</p> <p>Upper Hessenberg means H[i, j] == 0 for all i &gt; j + 1.</p>"},{"location":"api/decomp/qsvd/","title":"quatica.decomp.qsvd","text":""},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd","title":"<code>quatica.decomp.qsvd</code>","text":"<p>Quaternion SVD Implementations for QuatIca</p> <p>This module provides Q-SVD routines leveraging existing primitives in utils.py:</p> <ol> <li>Classical Q-SVD via real-block embedding and LAPACK</li> <li>Full Classical Q-SVD (no truncation)</li> <li>QR decomposition for quaternion matrices</li> <li>Randomized Q-SVD (rand_qsvd) using Gaussian sketching + power iterations</li> <li>Pass-efficient Q-SVD (pass_eff_qsvd) alternating a single QR per pass</li> </ol> <p>All routines operate on quaternion arrays (numpy.quaternion) and reuse utilities: - real_expand(Q), real_contract(R, m, n) - quat_matmat(A, B), quat_hermitian(A) - quat_frobenius_norm(A)</p> <p>References: - Ahmadi-Asl, S., Nobakht Kooshkghazi, M., &amp; Leplat, V. (2025).   Pass-efficient Randomized Algorithms for Low-rank Approximation of Quaternion Matrices.   arXiv:2507.13731</p> <p>Future Work: - Ma, R.-R., &amp; Bai, Z.-J. (2018). A Structure-Preserving One-Sided Jacobi Method   for Computing the SVD of a Quaternion Matrix. arXiv:1811.08671   This paper presents a more advanced, structure-preserving Q-SVD algorithm that will   be implemented in future releases for improved accuracy and efficiency.</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.classical_qsvd","title":"<code>classical_qsvd(X_quat, R)</code>","text":"<p>Classical Q-SVD via real-block embedding and LAPACK.</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.classical_qsvd--parameters","title":"Parameters:","text":"<p>X_quat : numpy.ndarray with dtype=quaternion     Input quaternion matrix of shape (m, n) R : int     Target rank for truncation</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.classical_qsvd--returns","title":"Returns:","text":"<p>tuple : (U_quat, s, V_quat)     U_quat : m\u00d7R quaternion matrix with orthonormal columns     s : R-length array of singular values     V_quat : n\u00d7R quaternion matrix with orthonormal columns</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.classical_qsvd--notes","title":"Notes:","text":"<p>Complexity: O((4m)(4n)min(4m,4n)), leverages optimized LAPACK. Handles degenerate singular values from real-block embedding by extracting every 4th singular value to obtain true quaternion singular values.</p> <p>For reconstruction: X \u2248 U @ diag(s) @ V^H (when R &lt; min(m,n))</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.classical_qsvd_full","title":"<code>classical_qsvd_full(X_quat)</code>","text":"<p>Full Classical Q-SVD via real-block embedding and LAPACK.</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.classical_qsvd_full--parameters","title":"Parameters:","text":"<p>X_quat : numpy.ndarray with dtype=quaternion     Input quaternion matrix of shape (m, n)</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.classical_qsvd_full--returns","title":"Returns:","text":"<p>tuple : (U_quat, s, V_quat)     U_quat : m\u00d7m quaternion matrix with orthonormal columns     s : min(m,n)-length array of singular values     V_quat : n\u00d7n quaternion matrix with orthonormal columns</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.classical_qsvd_full--notes","title":"Notes:","text":"<p>Returns the FULL Q-SVD decomposition without truncation. For reconstruction: X = U @ \u03a3 @ V^H where \u03a3 is the diagonal matrix with s.</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.pass_eff_qsvd","title":"<code>pass_eff_qsvd(X_quat, R, oversample=10, n_passes=2)</code>","text":"<p>Pass-efficient Q-SVD alternating single multiplies + QR.</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.pass_eff_qsvd--parameters","title":"Parameters:","text":"<p>X_quat : numpy.ndarray with dtype=quaternion     Input quaternion matrix of shape (m, n) R : int     Target rank oversample : int, optional     Oversampling parameter (default: 10) n_passes : int, optional     Number of passes over the matrix (default: 2)</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.pass_eff_qsvd--returns","title":"Returns:","text":"<p>tuple : (U_quat, s, V_quat)     U_quat : m\u00d7R quaternion matrix with orthonormal columns     s : R-length array of singular values     V_quat : n\u00d7R quaternion matrix with orthonormal columns</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.pass_eff_qsvd--notes","title":"Notes:","text":"<p>Advantage: fewer large passes over X, good cache behavior.</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.qr_qua","title":"<code>qr_qua(X_quat)</code>","text":"<p>QR decomposition of quaternion matrix using real-block embedding.</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.qr_qua--parameters","title":"Parameters:","text":"<p>X_quat : numpy.ndarray with dtype=quaternion     Input quaternion matrix of shape (m, n)</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.qr_qua--returns","title":"Returns:","text":"<p>tuple : (Q_quat, R_quat)     Q_quat : m\u00d7n quaternion matrix with orthonormal columns     R_quat : n\u00d7n upper triangular quaternion matrix</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.qr_qua--notes","title":"Notes:","text":"<p>Uses real-block embedding + SciPy's QR + contraction back to quaternion. Produces perfect reconstruction and orthonormal Q matrix.</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.rand_qsvd","title":"<code>rand_qsvd(X_quat, R, oversample=10, n_iter=2)</code>","text":"<p>Randomized Q-SVD using Gaussian sketching + power iterations.</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.rand_qsvd--parameters","title":"Parameters:","text":"<p>X_quat : numpy.ndarray with dtype=quaternion     Input quaternion matrix of shape (m, n) R : int     Target rank oversample : int, optional     Oversampling parameter (default: 10) n_iter : int, optional     Number of power iterations (default: 2)</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.rand_qsvd--returns","title":"Returns:","text":"<p>tuple : (U_quat, s, V_quat)     U_quat : m\u00d7R quaternion matrix with orthonormal columns     s : R-length array of singular values     V_quat : n\u00d7R quaternion matrix with orthonormal columns</p>"},{"location":"api/decomp/qsvd/#quatica.decomp.qsvd.rand_qsvd--notes","title":"Notes:","text":"<p>Cost: O(mn(R+P)) + O((R+P)\u00b2n) where P = oversample.</p>"},{"location":"api/decomp/schur/","title":"Schur Decomposition","text":""},{"location":"api/decomp/schur/#quatica.decomp.schur","title":"<code>quatica.decomp.schur</code>","text":"<p>Quaternion Schur Decomposition via Hessenberg reduction and implicit shifted QR.</p> <p>Strategy: - Reduce once to Hessenberg: H0 = P0 * A * P0^H - Iterate implicit shifted QR steps in Realp (4n x 4n) using quaternion-structured   Givens rotations and optional Francis double-shift for improved convergence:     HR_{k+1} = R_k @ Q_k + sigma_k I, where Q_k R_k \u2248 HR_k - sigma_k I - Accumulate total Q in real block, then contract to quaternion and combine with P0</p> <p>Notes: - Shift: Rayleigh, Wilkinson (1x1/2x2 trailing block), or double (Francis-style two shifts) - Deflation: aggressively zero H[i, i-1] when sufficiently small within the active window - All operations preserve quaternion structure through Realp mapping + fixed 8x8 permutation</p>"},{"location":"api/decomp/schur/#quatica.decomp.schur.quaternion_schur","title":"<code>quaternion_schur(A, max_iter=5000, tol=1e-12, shift='wilkinson', verbose=False, return_diagnostics=False)</code>","text":"<p>Compute a (quaternion) Schur-like decomposition A = Q T Q^H.</p> <p>Parameters: - A: square quaternion matrix (n x n) - max_iter: maximum number of QR iterations - tol: deflation tolerance for subdiagonal entries - shift: 'rayleigh' | 'wilkinson' | 'double' (Francis two-shift surrogate) - verbose: print progress</p> <p>Returns: - Q: unitary quaternion matrix - T: upper (quasi-)triangular quaternion matrix (Schur form)</p>"},{"location":"api/decomp/schur/#quatica.decomp.schur.quaternion_schur_experimental","title":"<code>quaternion_schur_experimental(A, variant='aed_windowed', max_iter=1000, tol=1e-10, window=12, verbose=False, return_diagnostics=False)</code>","text":"<p>Experimental Schur variants with windowed AED and a Francis-like two-shift chase.</p> <p>WARNING: Experimental. API and behavior may change. Does not affect stable variants.</p> Variants <ul> <li>'aed_windowed' : restrict bulge-chase and deflation to a trailing window (approx. AED)</li> <li>'francis_ds'   : perform a two-shift bulge chase per outer iteration (surrogate DS)</li> </ul> Notes <ul> <li>Operates purely in quaternion domain using 2x2 Householder similarities.</li> <li>Uses real scalar shifts derived from trailing block; keeps quaternion structure.</li> <li>Maintains similarity via left-row and right-column updates.</li> </ul>"},{"location":"api/decomp/schur/#quatica.decomp.schur.quaternion_schur_pure","title":"<code>quaternion_schur_pure(A, max_iter=500, tol=1e-10, verbose=False, return_diagnostics=False, shift_mode='none')</code>","text":"<p>Pure quaternion QR iteration (unshifted), no real expansion.</p> Algorithm <p>1) Reduce A to Hessenberg H via quaternion Householder similarity. 2) For k=1..max_iter: compute QR of H using quaternion Householders (left)    then set H &lt;- R @ Q (QR iteration). Accumulate Q_total.</p> <p>Note: Convergence is generally slower than shifted QR; intended as a structure-preserving baseline for Lead 2 experiments.</p>"},{"location":"api/decomp/schur/#quatica.decomp.schur.quaternion_schur_pure_implicit","title":"<code>quaternion_schur_pure_implicit(A, max_iter=500, tol=1e-10, verbose=False, return_diagnostics=False, shift_mode='rayleigh')</code>","text":"<p>Pure quaternion implicit QR via 2x2 Householder (bulge-chasing style).</p> <ul> <li>Keeps computation in quaternion domain</li> <li>Uses optional simple shift (Rayleigh) to accelerate convergence</li> <li>Left-apply 2x2 Householder to zero subdiagonal, right-apply its Hermitian to preserve similarity</li> </ul>"},{"location":"api/decomp/schur/#quatica.decomp.schur.quaternion_schur_unified","title":"<code>quaternion_schur_unified(A, variant='rayleigh', max_iter=1000, tol=1e-10, aed_factor=None, precompute_shifts=True, power_shift_steps=5, aed_window=None, verbose=False, return_diagnostics=False)</code>","text":"<p>Unified Schur API exposing common variants.</p> Variants <ul> <li>'none'       : pure QR iteration, no shift (Lead 2 baseline)</li> <li>'rayleigh'   : pure QR iteration with Rayleigh shift (Lead 2 simple shift)</li> <li>'implicit'   : pure quaternion implicit QR (bulge-chase) with Rayleigh shift</li> <li>'aed'        : implicit + aggressive early deflation (AED) (quaternion-only)</li> <li>'ds'         : implicit + double-shift surrogate from trailing 2x2 (quaternion-only)</li> </ul> Notes <ul> <li>For 'aed' and 'ds', operations stay in the quaternion domain using 2x2 Householder similarities.</li> <li>aed_window (optional): when set, restrict AED checks to the trailing window of size aed_window   to improve efficiency on larger matrices. Defaults to full sweep when None.</li> </ul>"},{"location":"api/decomp/tridiagonalize/","title":"quatica.decomp.tridiagonalize","text":""},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize","title":"<code>quatica.decomp.tridiagonalize</code>","text":"<p>Quaternion Matrix Tridiagonalization Module</p> <p>This module implements tridiagonalization of HERMITIAN quaternion matrices using Householder transformations.</p> <p>\u26a0\ufe0f  IMPORTANT: This implementation is ONLY for Hermitian quaternion matrices.    For non-Hermitian matrices, consider using the adjoint matrix approach.</p> <p>Main functions: - tridiagonalize: Convert Hermitian quaternion matrix to tridiagonal form - householder_matrix: Compute Householder transformation matrix - householder_vector: Compute Householder vector and zeta value - internal_tridiagonalizer: Recursive tridiagonalization algorithm</p> <p>Algorithm: Householder Transformations - Uses Householder transformations to eliminate subdiagonal elements - Converts Hermitian matrix A to tridiagonal form B: P * A * P^H = B - B is real tridiagonal with same eigenvalues as A - P is unitary transformation matrix</p> <p>Limitations: - Only works for Hermitian quaternion matrices - For non-Hermitian matrices, use adjoint matrix approach</p> <p>References: - MATLAB QTFM (Quaternion Toolbox for MATLAB) implementation: http://qtfm.sourceforge.net/ by Stephen J. Sangwine &amp; Nicolas Le Bihan</p>"},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize.check_tridiagonal","title":"<code>check_tridiagonal(B)</code>","text":"<p>Verify tridiagonalization results and convert to exactly tridiagonal form.</p>"},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize.check_tridiagonal--parameters","title":"Parameters:","text":"<p>B : quaternion matrix     Result from tridiagonalization</p>"},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize.check_tridiagonal--returns","title":"Returns:","text":"<p>B_clean : quaternion matrix     Cleaned tridiagonal matrix</p>"},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize.householder_matrix","title":"<code>householder_matrix(a, v)</code>","text":"<p>Compute Householder matrix that will zero all elements of a except those corresponding to non-zero elements of v.</p>"},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize.householder_matrix--parameters","title":"Parameters:","text":"<p>a : quaternion array     Vector to reflect v : numpy array (real)     Target vector (must be real)</p>"},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize.householder_matrix--returns","title":"Returns:","text":"<p>h : quaternion matrix     Householder transformation matrix</p>"},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize.householder_vector","title":"<code>householder_vector(a, v)</code>","text":"<p>Calculate a Householder vector u with norm sqrt(2) and value zeta.</p>"},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize.householder_vector--parameters","title":"Parameters:","text":"<p>a : quaternion array     Vector to reflect v : numpy array (real)     Target vector (must be real)</p>"},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize.householder_vector--returns","title":"Returns:","text":"<p>tuple : (u, zeta)     u : quaternion array (Householder vector)     zeta : quaternion (scalar value)</p>"},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize.internal_tridiagonalizer","title":"<code>internal_tridiagonalizer(A)</code>","text":"<p>Internal recursive tridiagonalization algorithm.</p>"},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize.internal_tridiagonalizer--parameters","title":"Parameters:","text":"<p>A : quaternion matrix     Hermitian matrix to tridiagonalize</p>"},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize.internal_tridiagonalizer--returns","title":"Returns:","text":"<p>tuple : (P, B)     P : quaternion matrix (unitary transformation)     B : quaternion matrix (tridiagonal result)</p>"},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize.tridiagonalize","title":"<code>tridiagonalize(A)</code>","text":"<p>Tridiagonalize Hermitian matrix A, such that P * A * P^H = B and P^H * B * P = A. B is real, P is unitary, and B has the same eigenvalues as A.</p>"},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize.tridiagonalize--parameters","title":"Parameters:","text":"<p>A : quaternion matrix     Hermitian matrix to tridiagonalize</p>"},{"location":"api/decomp/tridiagonalize/#quatica.decomp.tridiagonalize.tridiagonalize--returns","title":"Returns:","text":"<p>tuple : (P, B)     P : quaternion matrix (unitary transformation matrix)     B : quaternion matrix (tridiagonal result)</p>"},{"location":"applications/image_completion/","title":"Image Completion with QuatIca","text":""},{"location":"applications/image_completion/#overview","title":"Overview","text":"<p>QuatIca provides powerful quaternion-based image completion capabilities using advanced matrix decomposition techniques. This application demonstrates how quaternion matrices can effectively restore missing or corrupted image data.</p>"},{"location":"applications/image_completion/#key-features","title":"Key Features","text":"<ul> <li>Multiple completion strategies for different image types and corruption patterns</li> <li>Real image completion for practical restoration scenarios</li> <li>Synthetic image completion for controlled testing and validation</li> <li>Small image completion for rapid prototyping and development</li> </ul>"},{"location":"applications/image_completion/#available-scripts","title":"Available Scripts","text":""},{"location":"applications/image_completion/#real-image-completion","title":"Real Image Completion","text":"<p><pre><code>python applications/image_completion/script_real_image_completion.py\n</code></pre> Handles real-world image completion tasks with various corruption patterns and noise levels.</p>"},{"location":"applications/image_completion/#synthetic-image-completion","title":"Synthetic Image Completion","text":"<p><pre><code>python applications/image_completion/script_synthetic_image_completion.py\n</code></pre> Generates synthetic test cases for systematic evaluation of completion algorithms.</p>"},{"location":"applications/image_completion/#small-image-completion","title":"Small Image Completion","text":"<p><pre><code>python applications/image_completion/script_small_image_completion.py\n</code></pre> Optimized for quick testing with smaller image dimensions.</p>"},{"location":"applications/image_completion/#methodology","title":"Methodology","text":"<p>The image completion process leverages quaternion matrix factorization:</p> <ol> <li>Quaternion Encoding: Images are represented as quaternion matrices where each quaternion encodes color channel information</li> <li>Matrix Decomposition: Advanced quaternion SVD and factorization techniques identify underlying structure</li> <li>Completion Algorithm: Missing pixels are estimated using low-rank quaternion matrix completion</li> <li>Iterative Refinement: Newton-Schulz and other iterative methods refine the completion</li> </ol>"},{"location":"applications/image_completion/#applications","title":"Applications","text":"<ul> <li>Photo restoration - Repair damaged or corrupted images</li> <li>Missing data recovery - Complete images with systematic missing regions</li> <li>Noise reduction - Clean corrupted image data while preserving structure</li> <li>Compression artifacts removal - Restore quality in heavily compressed images</li> </ul>"},{"location":"applications/image_completion/#performance-benefits","title":"Performance Benefits","text":"<p>QuatIca's quaternion-based approach offers several advantages: - Color coherence - Naturally preserves color relationships across channels - Structural preservation - Maintains geometric features and patterns - Computational efficiency - Optimized quaternion operations reduce processing time - Robust completion - Handles various corruption patterns effectively</p>"},{"location":"applications/image_completion/#getting-started","title":"Getting Started","text":"<ol> <li>Prepare your image in a supported format (PNG, JPEG)</li> <li>Choose the appropriate script based on your completion task</li> <li>Configure parameters for corruption type and completion method</li> <li>Run the completion and examine results in <code>output_figures/</code></li> </ol> <p>For detailed parameter descriptions and advanced usage, see the individual script documentation.</p>"},{"location":"applications/image_deblurring/","title":"Image Deblurring with Quaternion Methods","text":"<p>Comprehensive guide to quaternion-based image deblurring using QSLST and Newton-Schulz methods.</p>"},{"location":"applications/image_deblurring/#overview","title":"\ud83c\udfaf Overview","text":"<p>QuatIca provides state-of-the-art quaternion methods for image deblurring, comparing:</p> <ul> <li>QSLST-FFT: Fast FFT-based Tikhonov regularization</li> <li>QSLST-Matrix: Matrix-based Tikhonov implementation</li> <li>Newton-Schulz (NS): Iterative pseudoinverse method</li> <li>Higher-Order NS (HON): Cubic convergence variant</li> </ul>"},{"location":"applications/image_deblurring/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"applications/image_deblurring/#basic-deblurring","title":"Basic Deblurring","text":"<pre><code># Default parameters (32\u00d732, fast)\npython run_analysis.py image_deblurring\n\n# High quality (64\u00d764, recommended)\npython run_analysis.py image_deblurring --size 64 --lam 1e-3 --snr 40 --ns_mode fftT --fftT_order 3 --ns_iters 12\n</code></pre>"},{"location":"applications/image_deblurring/#parameter-options","title":"Parameter Options","text":"<pre><code># Image size\n--size 32          # 32\u00d732 grid (fast)\n--size 64          # 64\u00d764 grid (recommended)\n--size 128         # 128\u00d7128 grid (high quality)\n\n# Regularization\n--lam 1e-3         # Tikhonov parameter (default: 1e-3)\n--lam 1e-1         # Stronger regularization\n--lam 1e-5         # Lighter regularization\n\n# Noise level\n--snr 30           # 30 dB signal-to-noise ratio\n--snr 40           # 40 dB SNR (default)\n--snr 50           # 50 dB SNR (less noise)\n\n# Newton-Schulz options\n--ns_mode fftT     # FFT-based (recommended)\n--ns_mode dense    # Dense matrix method\n--ns_mode sparse   # Sparse matrix method\n\n# FFT solver settings\n--fftT_order 2     # Quadratic convergence (Newton-Schulz)\n--fftT_order 3     # Cubic convergence (Higher-Order NS)\n--ns_iters 12      # Number of iterations\n</code></pre>"},{"location":"applications/image_deblurring/#algorithm-details","title":"\ud83d\udd2c Algorithm Details","text":""},{"location":"applications/image_deblurring/#problem-formulation","title":"Problem Formulation","text":"<p>Image Deblurring as Linear System: - Clean image: x (unknown) - Observed image: b (blurred + noise) - Blur operator: A (convolution matrix) - Goal: Solve Ax = b for x</p> <p>Tikhonov Regularization: <pre><code>minimize ||Ax - b||\u00b2 + \u03bb||x||\u00b2\n</code></pre></p> <p>Solution: <code>x_\u03bb = (A^T A + \u03bbI)^(-1) A^T b</code></p>"},{"location":"applications/image_deblurring/#method-comparison","title":"Method Comparison","text":"Method Speed Accuracy Memory Best For QSLST-FFT \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 Production use QSLST-Matrix \u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50 Small images, validation NS (fftT) \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 General purpose HON (fftT) \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 High accuracy"},{"location":"applications/image_deblurring/#qslst-fft-algorithm","title":"QSLST-FFT Algorithm","text":"<p>Why it's fast: FFT diagonalizes the circulant blur matrix A^T A</p> <pre><code># Frequency domain solution\nfor each frequency (u,v):\n    X\u0302[u,v] = conj(\u0124[u,v]) * B\u0302[u,v] / (|\u0124[u,v]|\u00b2 + \u03bb)\n</code></pre> <p>Complexity: O(N log N) vs O(N\u00b3) for direct methods</p>"},{"location":"applications/image_deblurring/#newton-schulz-fft-methods","title":"Newton-Schulz FFT Methods","text":"<p>Inverse Newton-Schulz: Solves T^(-1) where T = A^T A + \u03bbI</p> <pre><code># Iteration: Y \u2190 Y(2I - TY) (order-2)\n# Iteration: Y \u2190 Y(I + R + R\u00b2), R = I - TY (order-3)\n</code></pre> <p>Per-frequency implementation: Parallelizable across frequency bins</p>"},{"location":"applications/image_deblurring/#performance-analysis","title":"\ud83d\udcca Performance Analysis","text":""},{"location":"applications/image_deblurring/#execution-time-6464-image","title":"Execution Time (64\u00d764 image)","text":"Method Time Relative Speed QSLST-FFT ~0.1s 1\u00d7 (baseline) NS (fftT, order-2) ~0.3s 3\u00d7 HON (fftT, order-3) ~0.5s 5\u00d7 QSLST-Matrix ~2.5s 25\u00d7"},{"location":"applications/image_deblurring/#quality-metrics","title":"Quality Metrics","text":"<p>PSNR (Peak Signal-to-Noise Ratio): Higher is better - Excellent: &gt;40 dB - Good: 30-40 dB - Acceptable: 20-30 dB</p> <p>SSIM (Structural Similarity): Higher is better (0-1 range) - Excellent: &gt;0.95 - Good: 0.85-0.95 - Acceptable: 0.70-0.85</p>"},{"location":"applications/image_deblurring/#parameter-tuning-guide","title":"\ud83c\udf9b\ufe0f Parameter Tuning Guide","text":""},{"location":"applications/image_deblurring/#regularization-parameter","title":"Regularization Parameter (\u03bb)","text":"<p>Effect of \u03bb: - Too small (\u03bb &lt; 1e-5): Amplifies noise, overfitting - Optimal (\u03bb \u2248 1e-3): Balances smoothing and detail preservation - Too large (\u03bb &gt; 1e-1): Over-smoothing, loss of details</p> <p>Tuning strategy: <pre><code># Test different values\npython run_analysis.py image_deblurring --lam 1e-5  # Less smoothing\npython run_analysis.py image_deblurring --lam 1e-3  # Balanced (recommended)\npython run_analysis.py image_deblurring --lam 1e-1  # More smoothing\n</code></pre></p>"},{"location":"applications/image_deblurring/#newton-schulz-iterations","title":"Newton-Schulz Iterations","text":"<p>Convergence behavior: - Order-2: Linear convergence, needs ~12-20 iterations - Order-3: Cubic convergence, needs ~8-12 iterations</p> <p>Optimal settings: <pre><code># Balanced accuracy/speed\n--ns_mode fftT --fftT_order 3 --ns_iters 12\n\n# Maximum accuracy\n--ns_mode fftT --fftT_order 3 --ns_iters 20\n\n# Fast testing\n--ns_mode fftT --fftT_order 2 --ns_iters 10\n</code></pre></p>"},{"location":"applications/image_deblurring/#output-analysis","title":"\ud83d\uddbc\ufe0f Output Analysis","text":""},{"location":"applications/image_deblurring/#generated-files-in-output_figures","title":"Generated Files (in <code>output_figures/</code>)","text":"<ol> <li><code>image_deblurring_comparison.png</code>: Side-by-side results</li> <li><code>image_deblurring_metrics.png</code>: PSNR/SSIM comparison</li> <li><code>image_deblurring_timing.png</code>: Performance analysis</li> </ol>"},{"location":"applications/image_deblurring/#reading-the-results","title":"Reading the Results","text":"<p>Comparison Grid Layout: <pre><code>[Clean]    [Observed]  [QSLST-FFT]\n[QSLST-Matrix] [NS]    [HON]\n</code></pre></p> <p>Metrics Table: - PSNR: Image quality (higher = better) - SSIM: Structural similarity (closer to 1 = better) - Time: Processing time (lower = faster)</p>"},{"location":"applications/image_deblurring/#advanced-usage","title":"\ud83d\udd27 Advanced Usage","text":""},{"location":"applications/image_deblurring/#custom-blur-kernels","title":"Custom Blur Kernels","text":"<p>Modify the blur kernel in the script: <pre><code># Gaussian blur (default)\npsf = build_psf_gaussian(size, sigma=1.5)\n\n# Motion blur\ndef build_psf_motion(size, length, angle):\n    # Implementation for motion blur\n    pass\n\n# Custom kernel\npsf = your_custom_kernel(size)\n</code></pre></p>"},{"location":"applications/image_deblurring/#batch-processing","title":"Batch Processing","text":"<pre><code># Process multiple images\nfor size in 32 64 128; do\n    python applications/image_deblurring/script_image_deblurring.py \\\n        --size $size --lam 1e-3 --snr 40\ndone\n</code></pre>"},{"location":"applications/image_deblurring/#integration-with-other-tools","title":"Integration with Other Tools","text":"<pre><code># Use QuatIca deblurring in your pipeline\nimport sys, os\nsys.path.append('path/to/QuatIca/core')\n\nfrom qslst import qslst_restore_fft\nfrom utils import rgb_to_quat, quat_to_rgb\n\n# Your image processing pipeline\ndef deblur_image(rgb_image, blur_kernel, lambda_reg=1e-3):\n    quat_image = rgb_to_quat(rgb_image)\n    restored_quat = qslst_restore_fft(quat_image, blur_kernel, lambda_reg)\n    return quat_to_rgb(restored_quat)\n</code></pre>"},{"location":"applications/image_deblurring/#benchmark-results","title":"\ud83d\udcc8 Benchmark Results","text":""},{"location":"applications/image_deblurring/#accuracy-comparison-psnr-in-db","title":"Accuracy Comparison (PSNR in dB)","text":"Image Size QSLST-FFT QSLST-Matrix NS (fftT) HON (fftT) 32\u00d732 35.2 35.3 35.1 35.4 64\u00d764 33.8 33.9 33.7 34.0 128\u00d7128 32.1 32.2 32.0 32.3"},{"location":"applications/image_deblurring/#speed-comparison-seconds","title":"Speed Comparison (seconds)","text":"Image Size QSLST-FFT QSLST-Matrix NS (fftT) HON (fftT) 32\u00d732 0.05 0.8 0.15 0.25 64\u00d764 0.12 4.2 0.35 0.55 128\u00d7128 0.28 18.5 0.85 1.35"},{"location":"applications/image_deblurring/#recommendations","title":"\ud83c\udfaf Recommendations","text":""},{"location":"applications/image_deblurring/#for-production-use","title":"For Production Use","text":"<pre><code># Recommended settings for production\npython run_analysis.py image_deblurring \\\n    --size 64 \\\n    --lam 1e-3 \\\n    --snr 40 \\\n    --ns_mode fftT \\\n    --fftT_order 3 \\\n    --ns_iters 12\n</code></pre>"},{"location":"applications/image_deblurring/#for-researchvalidation","title":"For Research/Validation","text":"<pre><code># Maximum accuracy settings\npython run_analysis.py image_deblurring \\\n    --size 128 \\\n    --lam 1e-3 \\\n    --snr 50 \\\n    --ns_mode fftT \\\n    --fftT_order 3 \\\n    --ns_iters 20\n</code></pre>"},{"location":"applications/image_deblurring/#for-fast-prototyping","title":"For Fast Prototyping","text":"<pre><code># Quick testing settings\npython run_analysis.py image_deblurring \\\n    --size 32 \\\n    --lam 1e-3 \\\n    --ns_mode fftT \\\n    --fftT_order 2 \\\n    --ns_iters 10\n</code></pre>"},{"location":"applications/image_deblurring/#further-reading","title":"\ud83d\udd0d Further Reading","text":"<ul> <li>QSLST Paper: Fei, W., Tang, J., &amp; Shan, M. (2025). Quaternion special least squares with Tikhonov regularization method in image restoration.</li> <li>Newton-Schulz Methods: Classical iterative methods for matrix inversion</li> <li>FFT Deconvolution: Fast frequency-domain approaches to image restoration</li> </ul>"},{"location":"applications/image_deblurring/#next-steps","title":"\ud83c\udf93 Next Steps","text":"<ol> <li>Try different parameters: Experiment with \u03bb, image sizes, noise levels</li> <li>Test on your images: Replace the default image with your own</li> <li>Explore other applications: Check out Image Completion</li> <li>Understand the theory: Dive into the API documentation</li> </ol>"},{"location":"applications/lorenz_attractor/","title":"Lorenz Attractor Quaternion Filtering","text":""},{"location":"applications/lorenz_attractor/#overview","title":"Overview","text":"<p>This application demonstrates advanced quaternion filtering using the chaotic Lorenz attractor system. It showcases how quaternion linear algebra can be applied to signal processing and filtering problems with multi-dimensional chaotic data.</p>"},{"location":"applications/lorenz_attractor/#mathematical-foundation","title":"Mathematical Foundation","text":""},{"location":"applications/lorenz_attractor/#quaternion-signal-encoding","title":"Quaternion Signal Encoding","text":"<p>A three-dimensional signal is encoded as a quaternion-valued time series: <pre><code>x(t) = x_r(t)\ud835\udc22 + x_g(t)\ud835\udc23 + x_b(t)\ud835\udc24\n</code></pre> where <code>x_r</code>, <code>x_g</code>, <code>x_b</code> represent real-valued channels (e.g., RGB components).</p>"},{"location":"applications/lorenz_attractor/#quaternion-filter-design","title":"Quaternion Filter Design","text":"<p>We seek a finite-length quaternion filter <code>{w(s)}</code> such that: <pre><code>w(s) = w\u207d\u2070\u207e(s) + w\u207d\u02b3\u207e(s)\ud835\udc22 + w\u207d\u1d4d\u207e(s)\ud835\udc23 + w\u207d\u1d47\u207e(s)\ud835\udc24\n</code></pre></p> <p>The filtering operation uses right quaternion multiplication: <pre><code>y(t) = \u03a3 x(t-s) \u2217 w(s)\n</code></pre></p>"},{"location":"applications/lorenz_attractor/#lorenz-system-generation","title":"Lorenz System Generation","text":"<p>The target channels <code>(y_r, y_g, y_b)</code> are generated by numerically integrating the Lorenz system: <pre><code>dx/dt = \u03b1(y - x)\ndy/dt = x(\u03c1 - z) - y\ndz/dt = xy - \u03b2z\n</code></pre></p> <p>Parameters: - \u03b1 = 10 (coupling strength) - \u03b2 = 8/3 (damping parameter) - \u03c1 = 28 (driving parameter) - Initial condition: (x\u2080, y\u2080, z\u2080) = (1, 1, 1)</p>"},{"location":"applications/lorenz_attractor/#linear-system-formulation","title":"Linear System Formulation","text":"<p>The filtering problem becomes a quaternion linear system: <pre><code>X \u2217 w = y\n</code></pre> where: - X: Toeplitz-like quaternion data matrix - w: Unknown quaternion filter coefficients - y: Target quaternion signal from Lorenz system</p>"},{"location":"applications/lorenz_attractor/#available-scripts","title":"Available Scripts","text":""},{"location":"applications/lorenz_attractor/#q-gmres-lorenz-application","title":"Q-GMRES Lorenz Application","text":"<p><pre><code>python applications/signal_processing/lorenz_attractor_qgmres.py\n</code></pre> Demonstrates quaternion GMRES solver applied to Lorenz-based filtering problems.</p>"},{"location":"applications/lorenz_attractor/#method-comparison-benchmark","title":"Method Comparison Benchmark","text":"<p><pre><code>python applications/signal_processing/benchmark_lorenz_methods.py\n</code></pre> Compares Q-GMRES vs Newton-Schulz methods for Lorenz attractor filtering.</p>"},{"location":"applications/lorenz_attractor/#key-features","title":"Key Features","text":""},{"location":"applications/lorenz_attractor/#signal-processing-capabilities","title":"Signal Processing Capabilities","text":"<ul> <li>Multi-channel filtering with quaternion coherence</li> <li>Chaotic signal handling using Lorenz attractor dynamics</li> <li>Noise robustness with quaternion-aware processing</li> <li>Real-time filtering potential with optimized algorithms</li> </ul>"},{"location":"applications/lorenz_attractor/#solver-comparisons","title":"Solver Comparisons","text":"<ul> <li>Q-GMRES: Native quaternion iterative solver</li> <li>Block GMRES: Real-valued block formulation</li> <li>Newton-Schulz: Quaternion pseudoinverse methods</li> <li>Performance metrics: Convergence rates, residual analysis</li> </ul>"},{"location":"applications/lorenz_attractor/#applications","title":"Applications","text":""},{"location":"applications/lorenz_attractor/#signal-processing","title":"Signal Processing","text":"<ul> <li>Multi-channel audio filtering with spatial coherence</li> <li>Color image processing preserving chrominance relationships</li> <li>Sensor fusion for multi-dimensional data streams</li> <li>Chaotic system identification and control</li> </ul>"},{"location":"applications/lorenz_attractor/#research-applications","title":"Research Applications","text":"<ul> <li>Quaternion linear algebra method validation</li> <li>Iterative solver benchmarking for quaternion systems</li> <li>Chaotic dynamics in quaternion signal processing</li> <li>Filter design for multi-dimensional signals</li> </ul>"},{"location":"applications/lorenz_attractor/#performance-metrics","title":"Performance Metrics","text":"<p>The application reports relative residual: <pre><code>Residual = ||X \u2217 w - y||\u2082 / ||y||\u2082\n</code></pre></p> <p>Convergence criteria: - Tolerance: 10\u207b\u2076 - Maximum iterations: Number of unknowns - Comparison across GMRES, Block GMRES, and Q-GMRES</p>"},{"location":"applications/lorenz_attractor/#getting-started","title":"Getting Started","text":"<ol> <li>Run the Q-GMRES application to see quaternion filtering in action</li> <li>Execute the benchmark to compare different solution methods</li> <li>Examine output plots showing convergence and filtering results</li> <li>Modify parameters to explore different Lorenz dynamics</li> </ol> <p>This application provides a comprehensive example of quaternion linear algebra applied to chaotic signal processing, demonstrating the power and efficiency of QuatIca's quaternion-native algorithms.</p>"}]}